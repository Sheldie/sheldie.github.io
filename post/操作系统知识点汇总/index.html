<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shezzer&#39;s Blog</title>
<meta name="description" content="Shezzer的学习博客" />
<link rel="shortcut icon" href="https://sheldie.github.io/favicon.ico?v=1600064662856">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://sheldie.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://sheldie.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://sheldie.github.io/images/avatar.png?v=1600064662856" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Shezzer&#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89">操作系统的定义</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD">操作系统的功能</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">操作系统的基本特征</a></li>
<li><a href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">多道程序设计</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%9E%8B">操作系统的类型</a>
<ul>
<li><a href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">批处理操作系统</a></li>
<li><a href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F">分时系统</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C">程序执行</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C">程序的顺序执行</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91">并行与并发</a>
<ul>
<li><a href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5">并行与并发的概念</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E7%89%B9%E7%82%B9">程序并发执行的特点</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">进程和线程</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5">进程和线程的概念</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%B1%BB%E5%9E%8B">进程的类型</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%9B%E7%A8%8B">为什么需要进程？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B">为什么需要线程？</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB">进程与程序的区别</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">进程与线程的区别</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2">进程的状态及转换</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81">进程的三种基本状态</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7">进程挂起</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97">进程控制块</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5">进程控制块的概念</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E5%86%85%E5%AE%B9">进程控制块的内容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a>
<ul>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89">死锁的定义</a>
<ul>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5">死锁的概念</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9E%E4%BE%8B">死锁的实例</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0">死锁产生的原因</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁产生的必要条件</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95">解决死锁的方法</a>
<ul>
<li><a href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81">预防死锁</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81">避免死锁</a></li>
<li><a href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81">检测死锁</a></li>
<li><a href="#%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81">解除死锁</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="http://www.shezzer.com/" class="menu" style="animation-delay: 0.8s" target="_blank">
          生活博客
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://sheldie.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">操作系统知识点汇总</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-17 / 24 min read
        </div>
        
        <div class="post-content yue">
          <p>总结一些操作系统的基本概念，持续整理更新。</p>
<!-- more -->
<p>最近需要复习整理一下基础知识<br>
以下内容为转载整理，主要为个人学习使用。</p>
<h3 id="基本概念">基本概念</h3>
<h4 id="操作系统">操作系统</h4>
<h5 id="操作系统的定义">操作系统的定义</h5>
<p>操作系统是<strong>管理计算机硬件与软件资源的计算机程序</strong>。它加在裸机上的第一层软件，是整个计<br>
算机系统的核心，是系统应用程序和用户程序与硬件之间的接口。</p>
<h5 id="操作系统的功能">操作系统的功能</h5>
<ul>
<li><strong>处理器管理</strong>：处理器管理最基本的功能是<strong>处理中断</strong>事件，配置操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是<strong>处理器调度</strong>，针对不同情况采取不同的调度策略。</li>
<li><strong>存储器管理</strong>：存储器管理主要是指针对内存储器的管理。主要任务是<strong>分配内存空间</strong>，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中<strong>不互相干扰</strong>。</li>
<li><strong>设备管理</strong>：设备管理是指负责管理各类外围设备，包括分配、启动和故障处理等。主要任务是当用户使用外部设备时，必须提出要求，待操作系统进行统一分配后方可使用，使得多个用户能够<strong>共享设备</strong>。</li>
<li><strong>文件管理</strong>：文件管理是指操作系统对信息资源的管理。在操作系统中，将负责存取的管理信息的部分称为文件系统。文件管理支持文件的<strong>存储</strong>、<strong>检索</strong>和<strong>修改</strong>等操作以及文件的<strong>保护</strong>功能。</li>
<li><strong>作业管理</strong>：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制，这是根据用户的需要来控制作业运行的。</li>
<li><strong>用户接口</strong>：对用户与操作系统之间实际通讯的各种方式进行管理，为用户提供一个使用系统的良好环境。</li>
</ul>
<h5 id="操作系统的基本特征">操作系统的基本特征</h5>
<ul>
<li>并发性：concurrency</li>
<li>共享性：sharing</li>
<li>虚拟技术：virtual technology（时分复用 / 空分复用）</li>
<li>异步性：asynchronism</li>
</ul>
<h5 id="多道程序设计">多道程序设计</h5>
<ul>
<li>多道程序设计（multiprogramming）是指让多个程序同时进入计算机的主存储器进行计算。一般来说，单个程序并不能让 CPU 和 I/O 设备始终忙碌。单个用户通常具有多个运行程序。多道程序设计通过安排作业（编码与数据）使得 CPU 总有一个执行作业，从而提高 CPU 利用率。</li>
<li>特点：
<ul>
<li>多道、宏观上并行、微观上串行</li>
<li>CPU与外部设备充分并行</li>
<li>外部设备之间充分并行</li>
<li>发挥CPU的使用效率</li>
<li>提高单位时间的算题量</li>
</ul>
</li>
<li>不足：系统管理复杂化</li>
</ul>
<p>时间片</p>
<h4 id="操作系统的类型">操作系统的类型</h4>
<p>批处理操作系统、分时系统、实时系统、分布式操作系统、网络操作系统</p>
<h5 id="批处理操作系统">批处理操作系统</h5>
<h5 id="分时系统">分时系统</h5>
<ul>
<li>
<p>特点：共享性、并行性、<strong>交互性</strong>、独占性</p>
</li>
<li>
<p>分时系统要求计算机系统是<strong>可交互的</strong>（interactive），以便用户与系统直接通信。用户通过输入设备，如键盘、鼠标、触摸板、触摸屏等向操作系统或程序发出指令，并等待输出设备的即时结果。相应地，响应时间（response time）应当较短，通常小于 1 秒。</p>
</li>
<li>
<p>分时操作系统允许<strong>许多用户同时共享一台计算机</strong>。由于分时系统的每个动作或命令往往较短，因而每个用户只需少量 CPU 时间。随着系统从一个用户快速切换到另一个用户，每个用户都会感到整个系统只为自己所用，尽管它事实上为许多用户所共享。</p>
</li>
<li>
<p>分时操作系统采用 <strong>CPU 调度</strong>和<strong>多道程序设计</strong>，为每个用户提供一小部分的分时计算机资源。每个用户至少有一个程序在内存中。加载到内存并执行的程序，通常称为进程（process）。当进程执行时，它通常在执行较短的一段时间后，要么完成，要么需要进行 I/O 操作。</p>
</li>
<li>
<p>I/O 可以是交互的，即输出是到用户显示器，输入来自用户键盘、鼠标或其他设备。由于交互 I/O 通常按人类速度（people speed）来进行，因此可能需要很长时间完成。例如，输入通常受限于用户打字速度，每秒 7 个字符对人类来说可能很快，但是对计算机来说太慢了。在用户进行交互输入时，操作系统为了不让 CPU 空闲，会将 CPU 切换到其他用户程序。</p>
</li>
<li>
<p>分时系统和多道程序需要<strong>在内存中同时保存多个作业</strong>。如果有多个作业可以加载到内 存，同时内存太小而不能容纳所有这些作业，那么系统就应做出选择（这个决定涉及<strong>作业调度</strong>（job scheduling））。操作系统从作业池中选中一个作业，并将它调入内存以便执行。内存同时保存多个程序，这需要一定形式的内存管理。</p>
</li>
<li>
<p>另外，如果有多个任务同时等待执行，那么系统应当做出选择。做出这样的决策称为 <strong>CPU 调度</strong>（CPU scheduling）。最后，在多个作业并发执行时，操作系统的各个阶段，如进程调度、磁盘和内存管理，应能限制作业之间的互相影响。</p>
</li>
<li>
<p>对于分时系统，操作系统必须确保合理的响应时间。这有时可以通过交换（swapping）来得到，交换可将进程从磁盘调入内存，也可将进程从内存调到磁盘。不过，<strong>虚拟内存</strong>（virtual memory）是实现合理响应时间的更为常用的一种方法，虚拟内存允许一个执行作业不必完全在内存中。</p>
</li>
<li>
<p>虚拟内存的主要优点是，用户可执行比物理内存（physical memory）大的程序。再者，它将内存抽象成一个庞大的、统一的存储数组，将用户理解的逻辑内存（logical memory）与真正的物理内存区分幵来。这种安排使得程序员不受内存空间的限制。</p>
</li>
<li>
<p>分时系统也应提供文件系统。文件系统驻留在一组磁盘上，因此 也应提供磁盘管理。另外，分时系统需要提供机制，以便保护资源并防止不当使用。为了确保有序执行，系统必须提供机制，以便实现作业的同步和通信；它也可确保作业不会进入死锁，进而永远互相等待。</p>
</li>
<li>
<p><strong>分时系统和批处理系统的区别</strong>：目标不同、 适应作业的性质不同、资源使用率不同、作业控制方式不同</p>
</li>
</ul>
<hr>
<h3 id="进程">进程</h3>
<h4 id="程序执行">程序执行</h4>
<h5 id="程序的顺序执行">程序的顺序执行</h5>
<ul>
<li>指的是在有多个程序需要执行的情况下，处理器严格按照某一顺序按序执行，每次只执行一个程序。这个程序独占系统中所有资源，其执行不受外界影响，一道程序执行完后另一道才能开始。其实质是单道程序系统。</li>
<li>特点
<ul>
<li>顺序性：一个程序开始执行必须要等到前一个程序已执行完成</li>
<li>封闭性：程序一旦开始执行，其计算结果不受外界因素影响</li>
<li>可再现性：程序的结果与它的执行速度无关（即与时间无关），只要给定相同的输入，一定会得到相同的结果。</li>
</ul>
</li>
<li>不足：效率低下</li>
</ul>
<h4 id="并行与并发">并行与并发</h4>
<h5 id="并行与并发的概念">并行与并发的概念</h5>
<ul>
<li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</li>
<li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br>
<img src="https://sheldie.github.io/post-images/1587295176243.jpg" alt="并发与并行" loading="lazy"></li>
</ul>
<h5 id="程序并发执行的特点">程序并发执行的特点</h5>
<ul>
<li>
<p>资源共享性（失去封闭性）</p>
</li>
<li>
<p>独立性和制约性</p>
</li>
<li>
<p>程序执行的间断性</p>
</li>
<li>
<p>结果不可再现</p>
</li>
</ul>
<h4 id="进程和线程">进程和线程</h4>
<h5 id="进程和线程的概念">进程和线程的概念</h5>
<ul>
<li>进程：
<ul>
<li>是资源分配的最小单位。</li>
<li>一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>一个程序与其数据一道通过处理机的执行所发生的活动。</li>
</ul>
</li>
<li>线程：是进程的一个执行单元，是进程内的调度实体，是CPU调度的最小单位。</li>
</ul>
<h5 id="进程的特征">进程的特征</h5>
<ul>
<li>动态性：进程是程序的执行</li>
<li>并发性：多个进程可同存于内存中，能在一段时间内同时运行</li>
<li>独立性：独立运行的基本单位，独立获得资源和调度的基本单位</li>
<li>异步性：各进程按各自独立的不可预知的速度向前推进</li>
<li>结构特征：由用户程序 、用户数据、系统栈和进程控制块四部分组成</li>
</ul>
<h5 id="进程的类型">进程的类型</h5>
<ul>
<li>按其任务性质分：系统进程、用户进程</li>
<li>按其活动特点分：科学计算（受CPU时间限制）、商业联机事务处理（受I/O限制）</li>
</ul>
<h5 id="为什么需要进程">为什么需要进程？</h5>
<h5 id="为什么需要线程">为什么需要线程？</h5>
<p>每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。</p>
<ul>
<li>线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。</li>
<li>进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。</li>
</ul>
<h5 id="进程与程序的区别">进程与程序的区别</h5>
<ul>
<li>行为的一个规则叫做程序，程序在处理机上执行时所发生的活动称为进程</li>
<li><strong>程序是指令的有序集合</strong>，其本身没有任何运行的含义，是一个<strong>静态</strong>的概念。而进程是程序在处理机上的一次执行过程，它是一个<strong>动态</strong>的概念。</li>
<li>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<strong>程序是永久的，进程是暂时的。</strong></li>
<li>进程更能真实地描述并发，而程序不能</li>
<li>进程是由程序和数据两部分组成的</li>
<li>进程具有创建其他进程的功能，而程序没有</li>
<li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。</li>
</ul>
<h5 id="进程与线程的区别">进程与线程的区别</h5>
<ul>
<li><strong>根本区别</strong>：<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></li>
<li><strong>地址空间</strong>：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>
<li><strong>资源分配</strong>：进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
<ul>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</li>
</ul>
</li>
<li><strong>执行环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</li>
<li><strong>执行过程</strong>：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li><strong>切换开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li>
<li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
<li><strong>优缺点</strong>：<br>
线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。<br>
进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。</li>
<li><strong>使用场景</strong>：<br>
对资源的管理和保护要求高，不限制开销和效率时，使用多进程。<br>
要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</li>
</ul>
<blockquote>
<p>做个简单的比喻：进程=火车，线程=车厢</p>
<ul>
<li>线程在进程下行进（单纯的车厢无法运行）</li>
<li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li>
<li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li>
<li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li>
<li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li>
<li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－&quot;互斥锁&quot;</li>
<li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li>
</ul>
</blockquote>
<h4 id="进程的状态及转换">进程的状态及转换</h4>
<h5 id="进程的三种基本状态">进程的三种基本状态</h5>
<ul>
<li><strong>就绪状态（Ready）</strong>：存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行。这些进程所处的状态为就绪状态。</li>
<li><strong>运行状态（Running）</strong>：正在运行的进程所处的状态为运行状态。拥有CPU。</li>
<li><strong>等待状态（Wait / Blocked）</strong>：若一进程正在等待某一事件发生（如等待输入输出工作完成），这时，即使给它CPU，它也无法运行，称该进程处于等待状态、阻塞、 睡眠、封锁状态。</li>
</ul>
<blockquote>
<p>进程状态模型<br>
<img src="https://sheldie.github.io/post-images/1587295018931.png" alt="进程状态模型" loading="lazy"><br>
运行：进程当前处于运行状态。<br>
就绪；进程已准备好运行。<br>
阻塞；进程等待某些事件发生（如I/O操作）后才能运行。<br>
创建：进程刚产生，但还未被操作系统提交到可运行进程池中。<br>
消失（撤销）：进程被操作系统从可运行进程池中释放。</p>
</blockquote>
<h5 id="进程挂起">进程挂起</h5>
<p>处于非运行状态的进程：内存 → 外存</p>
<p>由于I/O操作比CPU计算慢得多，故常会出现内存中所有进程都等待I/O的现象。即使运行多个程序，处理器在大多数时间仍处于空闲状态。为此可采用交换方法，将内存中的一部分进程转移到磁盘中。在进程行为模式中需增加一个新的挂起状态，当内存所有进程阻塞时，操作系统可将一进程置为挂起状态并交换到磁盘，再调入另一进程执行。</p>
<p>挂起状态与原有的阻塞和就绪状态结合为<strong>阻塞挂起</strong>状态和<strong>就绪挂起</strong>状态。</p>
<blockquote>
<p>带有一个挂起状态<br>
<img src="https://sheldie.github.io/post-images/1587295052118.png" alt="带有一个挂起状态" loading="lazy"><br>
带有两个挂起状态<br>
<img src="https://sheldie.github.io/post-images/1587295122555.png" alt="带有两个挂起状态" loading="lazy"></p>
</blockquote>
<h4 id="进程控制块">进程控制块</h4>
<h5 id="进程控制块的概念">进程控制块的概念</h5>
<ul>
<li>为了描述一个进程和其它进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个<strong>与进程相联系的数据块</strong>，称为进程控制块（PCB）。</li>
<li>系统利用PCB来控制和管理进程，所以PCB是系统<strong>感知进程存在的唯一标志</strong></li>
<li>进程与PCB是一一对应的</li>
</ul>
<h5 id="进程控制块的内容">进程控制块的内容</h5>
<ul>
<li>进程标识
<ul>
<li>本进程的标识符(process ID)，唯一，通常是一个整数</li>
<li>创建本进程的进程（父进程）的标识符</li>
<li>用户标识符(user ID)；进程组关系</li>
</ul>
</li>
<li>处理器状态信息
<ul>
<li>通用寄存器</li>
<li>指令计数器</li>
<li>程序状态字PSW（状态码、状态信息）</li>
<li>用户栈指针</li>
</ul>
</li>
<li>进程调度信息
<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>调度所需其他信息：等待时间/执行时间等与调度算法有关</li>
<li>等待的事件</li>
</ul>
</li>
<li>进程控制信息
<ul>
<li>程序和数据地址</li>
<li>进程同步和通信机制：信号量、消息队列指针</li>
<li>资源清单</li>
<li>链接指针：下一个PCB的首址</li>
</ul>
</li>
</ul>
<hr>
<h3 id="死锁">死锁</h3>
<h4 id="死锁的定义">死锁的定义</h4>
<h5 id="死锁的概念">死锁的概念</h5>
<p>并发执行带来了新的问题：死锁。<br>
死锁是指<strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong>（互相等待），若无外力作用，它们都将无法再向前推进。</p>
<h5 id="死锁的实例">死锁的实例</h5>
<p>生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（同时拥有2只筷子才能吃）。某一个时候，一个拿了左筷子，一人拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭。<br>
在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p>
<h4 id="死锁产生的原因">死锁产生的原因</h4>
<ul>
<li>
<p>竞争资源</p>
<ul>
<li>
<p>系统中的<strong>资源可以分为两类</strong></p>
<ol>
<li><strong>可剥夺资源</strong>，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li><strong>不可剥夺资源</strong>，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ol>
</li>
<li>
<p>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
</li>
<li>
<p>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
</li>
</ul>
</li>
<li>
<p>进程间推进顺序非法</p>
<ul>
<li>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁</li>
<li>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</li>
</ul>
</li>
</ul>
<h4 id="死锁产生的必要条件">死锁产生的必要条件</h4>
<ul>
<li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程--资源的环形链。</li>
</ul>
<h4 id="解决死锁的方法">解决死锁的方法</h4>
<p>预防死锁、避免死锁、检查死锁、解除死锁</p>
<h5 id="预防死锁">预防死锁</h5>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
<ul>
<li>以确定的顺序获得锁：比如说进程P1：使用资源的顺序是R1、R2，进程P2：使用资源的顺序是R2、R1，如果采取动态分配的方式，就很有可能造成死锁。我们对设备进行分类编号，那么P1、P2只能以R1、R2的顺序来申请资源。就可以打破环形回路，避免死锁。</li>
<li>超时放弃：按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。</li>
</ul>
</li>
</ul>
<h5 id="避免死锁">避免死锁</h5>
<p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前<strong>预先计算资源分配的安全性</strong>。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法，它是DIJKstra E.W于1968年提出来的。</p>
<p>为什么叫做银行家算法呢，是因为这有点像银行的“借贷”服务，假如银行只有有限多的资金供给客户进行贷款服务，那么为了保证银行能有足够的资金运转，它在借钱之前要审核客户是否有能够在指定时间内偿还贷款的能力。<br>
在研究我们的操作系统的资源分配策略时，也会出现类似的问题，我们系统中的有限资源要分配给各种进程，那么就要事先考察此进程是否有在指定期限内归还资源的能力。必须要保证它能在有限的时间内进行归还，拱其他进程使用。</p>
<p>大致实现方法：</p>
<ol>
<li>当一个进程对资源的<strong>最大需求量不超过系统中的资源数时可以接纳该进程</strong>。</li>
<li>进程<strong>可以分期请求资源</strong>，当请求的总数不能超过最大需求量。</li>
<li>当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以<strong>推迟分配</strong>，但总能使进程在有限的时间里得到资源。</li>
<li>当系统现有的资源能满足进程尚需资源数时，必须测试<strong>系统现存的资源能否满足该进程尚需的最大资源数</strong>，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li>
</ol>
<p>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
<h5 id="检测死锁">检测死锁</h5>
<ul>
<li>首先为每个进程和每个资源指定一个唯一的号码</li>
<li>然后建立资源分配表和进程等待表</li>
</ul>
<h5 id="解除死锁">解除死锁</h5>
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<ul>
<li><strong>剥夺资源</strong>：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</li>
<li><strong>撤消进程</strong>：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</li>
</ul>
<hr>
<p>部分转载自：</p>
<ol>
<li>https://blog.csdn.net/hd12370/article/details/82814348</li>
<li>https://blog.csdn.net/ls5718/article/details/51896159?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1</li>
<li>https://www.zhihu.com/question/25532384/answer/411179772</li>
<li>https://www.cnblogs.com/zhuzhu2016/p/5804875.html</li>
<li>http://c.biancheng.net/view/1175.html</li>
</ol>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://sheldie.github.io/tag/SLcq3ecUT/">
            <span class="flex-auto">操作系统</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://sheldie.github.io/post/KNN算法/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  KNN算法
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://sheldie.github.io/post/动态规划/">
                <h3 class="post-title">
                  动态规划
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '0234359455b34f62ff4c',
    clientSecret: 'f493678fe574c168c8d416f30696a9324b3c1bfd',
    repo: 'sheldie.GiTalk',
    owner: 'Sheldie',
    admin: ['Sheldie'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://sheldie.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
