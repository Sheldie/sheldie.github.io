<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sheldie.github.io</id>
    <title>Shezzer&apos;s Blog</title>
    <updated>2020-04-22T05:20:15.609Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sheldie.github.io"/>
    <link rel="self" href="https://sheldie.github.io/atom.xml"/>
    <subtitle>Shezzer的技术博客</subtitle>
    <logo>https://sheldie.github.io/images/avatar.png</logo>
    <icon>https://sheldie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shezzer&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[KNN算法]]></title>
        <id>https://sheldie.github.io/post/KNN/</id>
        <link href="https://sheldie.github.io/post/KNN/">
        </link>
        <updated>2020-04-22T05:17:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="算法概述">算法概述</h3>
<p>KNN可以说是最简单的分类算法之一，同时，它也是最常用的分类算法之一，注意KNN算法是有监督学习中的分类算法，它看起来和另一个机器学习算法Kmeans有点像（Kmeans是无监督学习算法），但却是有本质区别的。其指导思想是”近朱者赤，近墨者黑“，即由你的邻居来推断出你的类别。</p>
<p>最简单最初级的分类器是将全部的训练数据所对应的类别都记录下来，当测试对象的属性和某个训练对象的属性完全匹配时，便可以对其进行分类。但是怎么可能所有测试对象都会找到与之完全匹配的训练对象呢，其次就是存在一个测试对象同时与多个训练对象匹配，导致一个训练对象被分到了多个类的问题，基于这些问题呢，就产生了KNN。</p>
<p>KNN是通过测量不同特征值之间的距离进行分类。它的思路是：如果一个样本在特征空间中的k个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别，其中K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。</p>
<p>如下图所示，如何判断绿色圆应该属于哪一类，是属于红色三角形还是属于蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被判定为属于红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆将被判定为属于蓝色四方形类。<br>
<img src="https://sheldie.github.io/post-images/1587532688031.png" alt="" loading="lazy"><br>
由于KNN最邻近分类算法在分类决策时只依据最邻近的一个或者几个样本的类别来决定待分类样本所属的类别，而不是靠判别类域的方法来确定所属类别的，因此对于<strong>类域的交叉或重叠较多的待分样本集</strong>来说，KNN方法较其他方法更为适合。</p>
<h3 id="算法介绍">算法介绍</h3>
<p>KNN算法的结果很大程度取决于K值的选择。</p>
<p>在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离：<br>
<img src="https://sheldie.github.io/post-images/1587532744965.jpg" alt="" loading="lazy"><br>
对KNN算法的思想进行总结：就是在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为：</p>
<ol>
<li>计算测试数据与各个训练数据之间的距离；</li>
<li>按照距离的递增关系进行排序；</li>
<li>选取距离最小的K个点；</li>
<li>确定前K个点所在类别的出现频率；</li>
<li>返回前K个点中出现频率最高的类别作为测试数据的预测分类。</li>
</ol>
<p>KNN算法的关键：</p>
<blockquote>
<ol>
<li>样本的所有特征都要做可比较的量化<br>
若是样本特征中存在非数值的类型，必须采取手段将其量化为数值。例如样本特征中包含颜色，可通过将颜色转换为灰度值来实现距离计算。</li>
<li>样本特征要做归一化处理<br>
样本有多个参数，每一个参数都有自己的定义域和取值范围，他们对距离计算的影响不一样，如取值较大的影响力会盖过取值较小的参数。所以样本参数必须做一些 scale 处理，最简单的方式就是所有特征的数值都采取归一化处置。</li>
<li>需要一个距离函数以计算两个样本之间的距离<br>
通常使用的距离函数有：欧氏距离、余弦距离、汉明距离、曼哈顿距离等，一般选欧氏距离作为距离度量，但是这是只适用于连续变量。在文本分类这种非连续变量情况下，汉明距离可以用来作为度量。通常情况下，如果运用一些特殊的算法来计算度量的话，K近邻分类精度可显著提高，如运用大边缘最近邻法或者近邻成分分析法。</li>
</ol>
</blockquote>
<p>K值选的太大易引起欠拟合，太小容易过拟合，需交叉验证确定K值（将样本数据按照一定比例，拆分出训练用的数据和验证用的数据，比如6：4拆分出部分训练数据和验证数据），从选取一个较小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K值。<br>
<img src="https://sheldie.github.io/post-images/1587532734421.png" alt="" loading="lazy"><br>
这个图其实很好理解，当增大k的时候，一般错误率会先降低，因为有周围更多的样本可以借鉴了，分类效果会变好。但注意，和K-means不一样，当K值更大的时候，错误率会更高。这也很好理解，比如说你一共就35个样本，当你K增大到30的时候，KNN基本上就没意义了。</p>
<p>所以选择K点的时候可以选择一个较大的临界K点，当它继续增大或减小的时候，错误率都会上升，比如图中的K=10。</p>
<h3 id="算法特点">算法特点</h3>
<p>KNN是一种<strong>非参的</strong>，<strong>惰性</strong>的算法模型。</p>
<p><strong>非参</strong>的意思并不是说这个算法不需要参数，而是意味着这个模型不会对数据做出任何的假设，与之相对的是线性回归（我们总会假设线性回归是一条直线）。也就是说KNN建立的模型结构是根据数据来决定的，这也比较符合现实的情况，毕竟在现实中的情况往往与理论上的假设是不相符的。</p>
<p><strong>惰性</strong>又是什么意思呢？想想看，同样是分类算法，逻辑回归需要先对数据进行大量训练（tranning），最后才会得到一个算法模型。而KNN算法却不需要，它没有明确的训练数据的过程，或者说这个过程很快。</p>
<p>算法优点：</p>
<ol>
<li>简单，易于理解，易于实现，无需估计参数，模型训练时间快</li>
<li>适合对稀有事件进行分类，对异常值不敏感</li>
<li>特别适合于多分类问题(multi-modal,对象具有多个类别标签)， KNN比SVM的表现要好。</li>
</ol>
<p>算法缺点：</p>
<ol>
<li>对内存要求较高，因为该算法存储了所有训练数据</li>
<li>预测阶段可能很慢</li>
<li>对不相关的功能和数据规模敏感（当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。可以采用权值的方法来改进。）</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://sheldie.github.io/post-images/1587532766265.png" alt="" loading="lazy"></figure>
<hr>
<p>转载自：</p>
<ol>
<li>https://www.cnblogs.com/ybjourney/p/4702562.html</li>
<li>https://www.cnblogs.com/listenfwind/p/10311496.html</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统知识点汇总]]></title>
        <id>https://sheldie.github.io/post/操作系统知识点汇总/</id>
        <link href="https://sheldie.github.io/post/操作系统知识点汇总/">
        </link>
        <updated>2020-04-17T02:00:30.000Z</updated>
        <summary type="html"><![CDATA[<p>总结一些操作系统的基本概念，持续整理更新。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总结一些操作系统的基本概念，持续整理更新。</p>
<!-- more -->
<p>最近需要复习整理一下基础知识<br>
以下内容为转载整理，主要为个人学习使用。</p>
<h3 id="基本概念">基本概念</h3>
<h4 id="操作系统">操作系统</h4>
<h5 id="操作系统的定义">操作系统的定义</h5>
<p>操作系统是<strong>管理计算机硬件与软件资源的计算机程序</strong>。它加在裸机上的第一层软件，是整个计<br>
算机系统的核心，是系统应用程序和用户程序与硬件之间的接口。</p>
<h5 id="操作系统的功能">操作系统的功能</h5>
<ul>
<li><strong>处理器管理</strong>：处理器管理最基本的功能是<strong>处理中断</strong>事件，配置操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是<strong>处理器调度</strong>，针对不同情况采取不同的调度策略。</li>
<li><strong>存储器管理</strong>：存储器管理主要是指针对内存储器的管理。主要任务是<strong>分配内存空间</strong>，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中<strong>不互相干扰</strong>。</li>
<li><strong>设备管理</strong>：设备管理是指负责管理各类外围设备，包括分配、启动和故障处理等。主要任务是当用户使用外部设备时，必须提出要求，待操作系统进行统一分配后方可使用，使得多个用户能够<strong>共享设备</strong>。</li>
<li><strong>文件管理</strong>：文件管理是指操作系统对信息资源的管理。在操作系统中，将负责存取的管理信息的部分称为文件系统。文件管理支持文件的<strong>存储</strong>、<strong>检索</strong>和<strong>修改</strong>等操作以及文件的<strong>保护</strong>功能。</li>
<li><strong>作业管理</strong>：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制，这是根据用户的需要来控制作业运行的。</li>
<li><strong>用户接口</strong>：对用户与操作系统之间实际通讯的各种方式进行管理，为用户提供一个使用系统的良好环境。</li>
</ul>
<h5 id="操作系统的基本特征">操作系统的基本特征</h5>
<ul>
<li>并发性：concurrency</li>
<li>共享性：sharing</li>
<li>虚拟技术：virtual technology（时分复用 / 空分复用）</li>
<li>异步性：asynchronism</li>
</ul>
<h5 id="多道程序设计">多道程序设计</h5>
<ul>
<li>多道程序设计（multiprogramming）是指让多个程序同时进入计算机的主存储器进行计算。一般来说，单个程序并不能让 CPU 和 I/O 设备始终忙碌。单个用户通常具有多个运行程序。多道程序设计通过安排作业（编码与数据）使得 CPU 总有一个执行作业，从而提高 CPU 利用率。</li>
<li>特点：
<ul>
<li>多道、宏观上并行、微观上串行</li>
<li>CPU与外部设备充分并行</li>
<li>外部设备之间充分并行</li>
<li>发挥CPU的使用效率</li>
<li>提高单位时间的算题量</li>
</ul>
</li>
<li>不足：系统管理复杂化</li>
</ul>
<p>时间片</p>
<h4 id="操作系统的类型">操作系统的类型</h4>
<p>批处理操作系统、分时系统、实时系统、分布式操作系统、网络操作系统</p>
<h5 id="批处理操作系统">批处理操作系统</h5>
<h5 id="分时系统">分时系统</h5>
<ul>
<li>
<p>特点：共享性、并行性、<strong>交互性</strong>、独占性</p>
</li>
<li>
<p>分时系统要求计算机系统是<strong>可交互的</strong>（interactive），以便用户与系统直接通信。用户通过输入设备，如键盘、鼠标、触摸板、触摸屏等向操作系统或程序发出指令，并等待输出设备的即时结果。相应地，响应时间（response time）应当较短，通常小于 1 秒。</p>
</li>
<li>
<p>分时操作系统允许<strong>许多用户同时共享一台计算机</strong>。由于分时系统的每个动作或命令往往较短，因而每个用户只需少量 CPU 时间。随着系统从一个用户快速切换到另一个用户，每个用户都会感到整个系统只为自己所用，尽管它事实上为许多用户所共享。</p>
</li>
<li>
<p>分时操作系统采用 <strong>CPU 调度</strong>和<strong>多道程序设计</strong>，为每个用户提供一小部分的分时计算机资源。每个用户至少有一个程序在内存中。加载到内存并执行的程序，通常称为进程（process）。当进程执行时，它通常在执行较短的一段时间后，要么完成，要么需要进行 I/O 操作。</p>
</li>
<li>
<p>I/O 可以是交互的，即输出是到用户显示器，输入来自用户键盘、鼠标或其他设备。由于交互 I/O 通常按人类速度（people speed）来进行，因此可能需要很长时间完成。例如，输入通常受限于用户打字速度，每秒 7 个字符对人类来说可能很快，但是对计算机来说太慢了。在用户进行交互输入时，操作系统为了不让 CPU 空闲，会将 CPU 切换到其他用户程序。</p>
</li>
<li>
<p>分时系统和多道程序需要<strong>在内存中同时保存多个作业</strong>。如果有多个作业可以加载到内 存，同时内存太小而不能容纳所有这些作业，那么系统就应做出选择（这个决定涉及<strong>作业调度</strong>（job scheduling））。操作系统从作业池中选中一个作业，并将它调入内存以便执行。内存同时保存多个程序，这需要一定形式的内存管理。</p>
</li>
<li>
<p>另外，如果有多个任务同时等待执行，那么系统应当做出选择。做出这样的决策称为 <strong>CPU 调度</strong>（CPU scheduling）。最后，在多个作业并发执行时，操作系统的各个阶段，如进程调度、磁盘和内存管理，应能限制作业之间的互相影响。</p>
</li>
<li>
<p>对于分时系统，操作系统必须确保合理的响应时间。这有时可以通过交换（swapping）来得到，交换可将进程从磁盘调入内存，也可将进程从内存调到磁盘。不过，<strong>虚拟内存</strong>（virtual memory）是实现合理响应时间的更为常用的一种方法，虚拟内存允许一个执行作业不必完全在内存中。</p>
</li>
<li>
<p>虚拟内存的主要优点是，用户可执行比物理内存（physical memory）大的程序。再者，它将内存抽象成一个庞大的、统一的存储数组，将用户理解的逻辑内存（logical memory）与真正的物理内存区分幵来。这种安排使得程序员不受内存空间的限制。</p>
</li>
<li>
<p>分时系统也应提供文件系统。文件系统驻留在一组磁盘上，因此 也应提供磁盘管理。另外，分时系统需要提供机制，以便保护资源并防止不当使用。为了确保有序执行，系统必须提供机制，以便实现作业的同步和通信；它也可确保作业不会进入死锁，进而永远互相等待。</p>
</li>
<li>
<p><strong>分时系统和批处理系统的区别</strong>：目标不同、 适应作业的性质不同、资源使用率不同、作业控制方式不同</p>
</li>
</ul>
<hr>
<h3 id="进程">进程</h3>
<h4 id="程序执行">程序执行</h4>
<h5 id="程序的顺序执行">程序的顺序执行</h5>
<ul>
<li>指的是在有多个程序需要执行的情况下，处理器严格按照某一顺序按序执行，每次只执行一个程序。这个程序独占系统中所有资源，其执行不受外界影响，一道程序执行完后另一道才能开始。其实质是单道程序系统。</li>
<li>特点
<ul>
<li>顺序性：一个程序开始执行必须要等到前一个程序已执行完成</li>
<li>封闭性：程序一旦开始执行，其计算结果不受外界因素影响</li>
<li>可再现性：程序的结果与它的执行速度无关（即与时间无关），只要给定相同的输入，一定会得到相同的结果。</li>
</ul>
</li>
<li>不足：效率低下</li>
</ul>
<h4 id="并行与并发">并行与并发</h4>
<h5 id="并行与并发的概念">并行与并发的概念</h5>
<ul>
<li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</li>
<li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br>
<img src="https://sheldie.github.io/post-images/1587295176243.jpg" alt="并发与并行" loading="lazy"></li>
</ul>
<h5 id="程序并发执行的特点">程序并发执行的特点</h5>
<ul>
<li>
<p>资源共享性（失去封闭性）</p>
</li>
<li>
<p>独立性和制约性</p>
</li>
<li>
<p>程序执行的间断性</p>
</li>
<li>
<p>结果不可再现</p>
</li>
</ul>
<h4 id="进程和线程">进程和线程</h4>
<h5 id="进程和线程的概念">进程和线程的概念</h5>
<ul>
<li>进程：
<ul>
<li>是资源分配的最小单位。</li>
<li>一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>一个程序与其数据一道通过处理机的执行所发生的活动。</li>
</ul>
</li>
<li>线程：是进程的一个执行单元，是进程内的调度实体，是CPU调度的最小单位。</li>
</ul>
<h5 id="进程的特征">进程的特征</h5>
<ul>
<li>动态性：进程是程序的执行</li>
<li>并发性：多个进程可同存于内存中，能在一段时间内同时运行</li>
<li>独立性：独立运行的基本单位，独立获得资源和调度的基本单位</li>
<li>异步性：各进程按各自独立的不可预知的速度向前推进</li>
<li>结构特征：由用户程序 、用户数据、系统栈和进程控制块四部分组成</li>
</ul>
<h5 id="进程的类型">进程的类型</h5>
<ul>
<li>按其任务性质分：系统进程、用户进程</li>
<li>按其活动特点分：科学计算（受CPU时间限制）、商业联机事务处理（受I/O限制）</li>
</ul>
<h5 id="为什么需要进程">为什么需要进程？</h5>
<h5 id="为什么需要线程">为什么需要线程？</h5>
<p>每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。</p>
<ul>
<li>线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。</li>
<li>进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。</li>
</ul>
<h5 id="进程与程序的区别">进程与程序的区别</h5>
<ul>
<li>行为的一个规则叫做程序，程序在处理机上执行时所发生的活动称为进程</li>
<li><strong>程序是指令的有序集合</strong>，其本身没有任何运行的含义，是一个<strong>静态</strong>的概念。而进程是程序在处理机上的一次执行过程，它是一个<strong>动态</strong>的概念。</li>
<li>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<strong>程序是永久的，进程是暂时的。</strong></li>
<li>进程更能真实地描述并发，而程序不能</li>
<li>进程是由程序和数据两部分组成的</li>
<li>进程具有创建其他进程的功能，而程序没有</li>
<li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。</li>
</ul>
<h5 id="进程与线程的区别">进程与线程的区别</h5>
<ul>
<li><strong>根本区别</strong>：<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></li>
<li><strong>地址空间</strong>：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>
<li><strong>资源分配</strong>：进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
<ul>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</li>
</ul>
</li>
<li><strong>执行环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</li>
<li><strong>执行过程</strong>：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li><strong>切换开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li>
<li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
<li><strong>优缺点</strong>：<br>
线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。<br>
进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。</li>
<li><strong>使用场景</strong>：<br>
对资源的管理和保护要求高，不限制开销和效率时，使用多进程。<br>
要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</li>
</ul>
<blockquote>
<p>做个简单的比喻：进程=火车，线程=车厢</p>
<ul>
<li>线程在进程下行进（单纯的车厢无法运行）</li>
<li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li>
<li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li>
<li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li>
<li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li>
<li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－&quot;互斥锁&quot;</li>
<li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li>
</ul>
</blockquote>
<h4 id="进程的状态及转换">进程的状态及转换</h4>
<h5 id="进程的三种基本状态">进程的三种基本状态</h5>
<ul>
<li><strong>就绪状态（Ready）</strong>：存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行。这些进程所处的状态为就绪状态。</li>
<li><strong>运行状态（Running）</strong>：正在运行的进程所处的状态为运行状态。拥有CPU。</li>
<li><strong>等待状态（Wait / Blocked）</strong>：若一进程正在等待某一事件发生（如等待输入输出工作完成），这时，即使给它CPU，它也无法运行，称该进程处于等待状态、阻塞、 睡眠、封锁状态。</li>
</ul>
<blockquote>
<p>进程状态模型<br>
<img src="https://sheldie.github.io/post-images/1587295018931.png" alt="进程状态模型" loading="lazy"><br>
运行：进程当前处于运行状态。<br>
就绪；进程已准备好运行。<br>
阻塞；进程等待某些事件发生（如I/O操作）后才能运行。<br>
创建：进程刚产生，但还未被操作系统提交到可运行进程池中。<br>
消失（撤销）：进程被操作系统从可运行进程池中释放。</p>
</blockquote>
<h5 id="进程挂起">进程挂起</h5>
<p>处于非运行状态的进程：内存 → 外存</p>
<p>由于I/O操作比CPU计算慢得多，故常会出现内存中所有进程都等待I/O的现象。即使运行多个程序，处理器在大多数时间仍处于空闲状态。为此可采用交换方法，将内存中的一部分进程转移到磁盘中。在进程行为模式中需增加一个新的挂起状态，当内存所有进程阻塞时，操作系统可将一进程置为挂起状态并交换到磁盘，再调入另一进程执行。</p>
<p>挂起状态与原有的阻塞和就绪状态结合为<strong>阻塞挂起</strong>状态和<strong>就绪挂起</strong>状态。</p>
<blockquote>
<p>带有一个挂起状态<br>
<img src="https://sheldie.github.io/post-images/1587295052118.png" alt="带有一个挂起状态" loading="lazy"><br>
带有两个挂起状态<br>
<img src="https://sheldie.github.io/post-images/1587295122555.png" alt="带有两个挂起状态" loading="lazy"></p>
</blockquote>
<h4 id="进程控制块">进程控制块</h4>
<h5 id="进程控制块的概念">进程控制块的概念</h5>
<ul>
<li>为了描述一个进程和其它进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个<strong>与进程相联系的数据块</strong>，称为进程控制块（PCB）。</li>
<li>系统利用PCB来控制和管理进程，所以PCB是系统<strong>感知进程存在的唯一标志</strong></li>
<li>进程与PCB是一一对应的</li>
</ul>
<h5 id="进程控制块的内容">进程控制块的内容</h5>
<ul>
<li>进程标识
<ul>
<li>本进程的标识符(process ID)，唯一，通常是一个整数</li>
<li>创建本进程的进程（父进程）的标识符</li>
<li>用户标识符(user ID)；进程组关系</li>
</ul>
</li>
<li>处理器状态信息
<ul>
<li>通用寄存器</li>
<li>指令计数器</li>
<li>程序状态字PSW（状态码、状态信息）</li>
<li>用户栈指针</li>
</ul>
</li>
<li>进程调度信息
<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>调度所需其他信息：等待时间/执行时间等与调度算法有关</li>
<li>等待的事件</li>
</ul>
</li>
<li>进程控制信息
<ul>
<li>程序和数据地址</li>
<li>进程同步和通信机制：信号量、消息队列指针</li>
<li>资源清单</li>
<li>链接指针：下一个PCB的首址</li>
</ul>
</li>
</ul>
<hr>
<h3 id="死锁">死锁</h3>
<h4 id="死锁的定义">死锁的定义</h4>
<h5 id="死锁的概念">死锁的概念</h5>
<p>并发执行带来了新的问题：死锁。<br>
死锁是指<strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong>（互相等待），若无外力作用，它们都将无法再向前推进。</p>
<h5 id="死锁的实例">死锁的实例</h5>
<p>生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（同时拥有2只筷子才能吃）。某一个时候，一个拿了左筷子，一人拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭。<br>
在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p>
<h4 id="死锁产生的原因">死锁产生的原因</h4>
<ul>
<li>
<p>竞争资源</p>
<ul>
<li>
<p>系统中的<strong>资源可以分为两类</strong></p>
<ol>
<li><strong>可剥夺资源</strong>，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li><strong>不可剥夺资源</strong>，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ol>
</li>
<li>
<p>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
</li>
<li>
<p>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
</li>
</ul>
</li>
<li>
<p>进程间推进顺序非法</p>
<ul>
<li>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁</li>
<li>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</li>
</ul>
</li>
</ul>
<h4 id="死锁产生的必要条件">死锁产生的必要条件</h4>
<ul>
<li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程--资源的环形链。</li>
</ul>
<h4 id="解决死锁的方法">解决死锁的方法</h4>
<p>预防死锁、避免死锁、检查死锁、解除死锁</p>
<h5 id="预防死锁">预防死锁</h5>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
<ul>
<li>以确定的顺序获得锁：比如说进程P1：使用资源的顺序是R1、R2，进程P2：使用资源的顺序是R2、R1，如果采取动态分配的方式，就很有可能造成死锁。我们对设备进行分类编号，那么P1、P2只能以R1、R2的顺序来申请资源。就可以打破环形回路，避免死锁。</li>
<li>超时放弃：按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。</li>
</ul>
</li>
</ul>
<h5 id="避免死锁">避免死锁</h5>
<p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前<strong>预先计算资源分配的安全性</strong>。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法，它是DIJKstra E.W于1968年提出来的。</p>
<p>为什么叫做银行家算法呢，是因为这有点像银行的“借贷”服务，假如银行只有有限多的资金供给客户进行贷款服务，那么为了保证银行能有足够的资金运转，它在借钱之前要审核客户是否有能够在指定时间内偿还贷款的能力。<br>
在研究我们的操作系统的资源分配策略时，也会出现类似的问题，我们系统中的有限资源要分配给各种进程，那么就要事先考察此进程是否有在指定期限内归还资源的能力。必须要保证它能在有限的时间内进行归还，拱其他进程使用。</p>
<p>大致实现方法：</p>
<ol>
<li>当一个进程对资源的<strong>最大需求量不超过系统中的资源数时可以接纳该进程</strong>。</li>
<li>进程<strong>可以分期请求资源</strong>，当请求的总数不能超过最大需求量。</li>
<li>当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以<strong>推迟分配</strong>，但总能使进程在有限的时间里得到资源。</li>
<li>当系统现有的资源能满足进程尚需资源数时，必须测试<strong>系统现存的资源能否满足该进程尚需的最大资源数</strong>，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li>
</ol>
<p>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
<h5 id="检测死锁">检测死锁</h5>
<ul>
<li>首先为每个进程和每个资源指定一个唯一的号码</li>
<li>然后建立资源分配表和进程等待表</li>
</ul>
<h5 id="解除死锁">解除死锁</h5>
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<ul>
<li><strong>剥夺资源</strong>：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</li>
<li><strong>撤消进程</strong>：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</li>
</ul>
<hr>
<p>部分转载自：</p>
<ol>
<li>https://blog.csdn.net/hd12370/article/details/82814348</li>
<li>https://blog.csdn.net/ls5718/article/details/51896159?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1</li>
<li>https://www.zhihu.com/question/25532384/answer/411179772</li>
<li>https://www.cnblogs.com/zhuzhu2016/p/5804875.html</li>
<li>http://c.biancheng.net/view/1175.html</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划]]></title>
        <id>https://sheldie.github.io/post/动态规划/</id>
        <link href="https://sheldie.github.io/post/动态规划/">
        </link>
        <updated>2020-04-16T07:30:30.000Z</updated>
        <summary type="html"><![CDATA[<p>总结动态规划问题的基本思路（待更新）</p>
]]></summary>
        <content type="html"><![CDATA[<p>总结动态规划问题的基本思路（待更新）</p>
<!-- more -->
<h3 id="基本思路">基本思路</h3>
<p>图片转载自<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">leetcode</a></p>
<figure data-type="image" tabindex="1"><img src="https://sheldie.github.io/post-images/1587022409662.png" alt="动态规划问题的基本思路" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python词频统计]]></title>
        <id>https://sheldie.github.io/post/python词频统计/</id>
        <link href="https://sheldie.github.io/post/python词频统计/">
        </link>
        <updated>2020-04-14T14:23:47.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 Python 对 txt 文件做简单的词频统计</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 Python 对 txt 文件做简单的词频统计</p>
<!-- more -->
<p>今天由于某些原因，实现了个简单的文本词频统计。</p>
<h3 id="背景">背景</h3>
<p>Python方面仍然还是入门水准，使用起来并不是很顺手。<br>
正则表达式也不是很熟，学习了一些最基本的用法，后续会进行整理。</p>
<h3 id="需求">需求</h3>
<ol>
<li>读入文件</li>
<li>实现对文本中单词的词频统计</li>
<li>将单词的出现位置输出到文件中</li>
<li>根据单词词性，将 名词单复数 及 动词各种形式 看作同一个单词<code>（难）</code></li>
</ol>
<h3 id="思路">思路</h3>
<p>首先读入文件。</p>
<p>然后按行来读取文件，每行按正则表达式读取单词。<br>
这里我用的是：<code>[a-zA-Z\']+</code><br>
有些单词内可能有 ‘，所以把这个也写入正则表达式了。</p>
<p>新建一个<strong>列表</strong>和一个<strong>字典</strong><br>
直接将读取到的单词存入列表<br>
把该单词的位置 以<strong>元组</strong>的形式 存入字典，字典值的数据类型为列表<br>
元组格式为：<code>（行号，单词序数）</code>，如第1行第3个单词为 (0, 2)</p>
<p>整个文本都读取完之后<br>
利用Counter直接对列表中的单词词频进行统计<br>
将字典中存储的位置输出到一个新的txt文件中</p>
<h3 id="代码">代码</h3>
<pre><code>def wordcount(filename):
    fi = open(filename, &quot;r&quot;, encoding=&quot;utf-8-sig&quot;)
    words_box = []
    words_idx = {}

    row = 0
    for line in fi.readlines():
        line = line.rstrip('\n').strip().lower()
        ls = re.findall('[a-zA-Z\']+', line)

        idx = 0
        for word in ls:
            if word not in words_idx:
                words_idx[word] = []
            words_idx[word].append((row, idx))
            idx += 1

        row += 1

    counter = Counter(words_box)
    for i in counter:
        print('%s: %d' % (i, counter.get(i)))

    fo = open(&quot;result.txt&quot;, 'w+', encoding=&quot;utf-8&quot;)
    for word in sorted(words_idx):
        op = word + ' ' + str(words_idx.get(word)) + '\n'
        print(op, end=&quot;&quot;)
        fo.write(op)
</code></pre>
<p>有个细节：打开文件后读取第一行时，最前面出现了<code>\ufeff</code>（字节顺序标记）</p>
<p>找到的资料如下：<br>
UTF-8以字节为编码单元，它的字节顺序在所有系统中都是一样的，没有字节序的问题，也因此它实际上并不需要BOM(“ByteOrder Mark”)。但是UTF-8 with BOM即utf-8-sig需要提供BOM。</p>
<p>因此将编码格式改为<code>utf-8-sig</code>即可。</p>
<hr>
<p>目前来说除了第四条需求都已基本完成。</p>
<p>关于词性判断，也就是第四条需求，感觉难度过大。<br>
初步判断需要借助库，涉及NLP，有点超出我目前的学习范围，暂时弃坑。<br>
网上搜索资料后，找到<strong>NLTK</strong>库。<br>
观察了运行结果，应该是比较符合需求的。</p>
<p>思路是：判断出单词词性后，对后缀进行调整或者删除，再进行统计或者匹配。<br>
找了一篇相关的经验贴：<a href="https://www.jianshu.com/p/418cbdbf5e20">Python nltk 英文词性分析</a><br>
例如：判断出该单词为NNS（名词复数），可以考虑删除 s 和 es 等后缀。<br>
理论上来说是有可操作性的，以后若使用到NLTK会进行尝试。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客说明]]></title>
        <id>https://sheldie.github.io/post/博客说明/</id>
        <link href="https://sheldie.github.io/post/博客说明/">
        </link>
        <updated>2020-04-13T13:56:49.000Z</updated>
        <summary type="html"><![CDATA[<p>本博客新建于2020年4月 🙄<br>
主要用于个人学习 🚀<br>
以前的内容就不搬过来了<br>
之后会陆续更新的~</p>
]]></summary>
        <content type="html"><![CDATA[<p>本博客新建于2020年4月 🙄<br>
主要用于个人学习 🚀<br>
以前的内容就不搬过来了<br>
之后会陆续更新的~</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式与集群]]></title>
        <id>https://sheldie.github.io/post/分布式与集群/</id>
        <link href="https://sheldie.github.io/post/分布式与集群/">
        </link>
        <updated>2020-04-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>转载自：</p>
<ol>
<li>
<p>分布式与集群的区别是什么？ - 大闲人柴毛毛的回答 - 知乎<br>
https://www.zhihu.com/question/20004877/answer/282033178</p>
</li>
<li>
<p>分布式与集群的区别是什么？ - 灵剑的回答 - 知乎<br>
https://www.zhihu.com/question/20004877/answer/568581790</p>
</li>
</ol>
<h3 id="单机结构"><strong>单机结构</strong></h3>
<p>我想大家最最最熟悉的就是单机结构，一个系统业务量很小的时候所有的代码都放在一个项目中就好了，然后这个项目部署在一台服务器上就好了。整个项目所有的服务都由这台服务器提供。这就是单机结构。</p>
<p>那么，单机结构有啥缺点呢？我想缺点是显而易见的，单机的处理能力毕竟是有限的，当你的业务增长到一定程度的时候，单机的硬件资源将无法满足你的业务需求。此时便出现了集群模式，往下接着看。</p>
<h3 id="集群结构"><strong>集群结构</strong></h3>
<p>单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。</p>
<p>但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。</p>
<p>集群结构的好处就是系统扩展非常容易。如果随着你们系统业务的发展，当前的系统又支撑不住了，那么给这个集群再增加节点就行了。但是，当你的业务发展到一定程度的时候，你会发现一个问题——无论怎么增加节点，貌似整个集群性能的提升效果并不明显了。这时候，你就需要使用微服务结构了。</p>
<h3 id="分布式结构"><strong>分布式结构</strong></h3>
<p>先来对前面的知识点做个总结。</p>
<p>从单机结构到集群结构，你的代码基本无需要作任何修改，你要做的仅仅是多部署几台服务器，每台服务器上运行相同的代码就行了。但是，当你要从集群结构演进到微服务结构的时候，之前的那套代码就需要发生较大的改动了。所以对于新系统我们建议，系统设计之初就采用微服务架构，这样后期运维的成本更低。但如果一套老系统需要升级成微服务结构的话，那就得对代码大动干戈了。所以，对于老系统而言，究竟是继续保持集群模式，还是升级成微服务架构，这需要你们的架构师深思熟虑、权衡投入产出比。</p>
<p>OK，下面开始介绍所谓的分布式结构。</p>
<p>分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。</p>
<p>举个例子，假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。</p>
<p>这样的好处有很多：</p>
<ol>
<li>系统之间的耦合度大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。</li>
<li>系统之间的耦合度降低，从而系统更易于扩展。我们可以针对性地扩展某些服务。假设这个商城要搞一次大促，下单量可能会大大提升，因此我们可以针对性地提升订单系统、产品系统的节点数量，而对于后台管理系统、数据分析系统而言，节点数量维持原有水平即可。</li>
<li>服务的复用性更高。比如，当我们将用户系统作为单独的服务后，该公司所有的产品都可以使用该系统作为用户系统，无需重复开发。</li>
</ol>
<h3 id="补充">补充</h3>
<p>其实分布式不一定就是不同的组件，同一个组件也可以，关键在于是否通过交换信息的方式进行协作。比如说Zookeeper的节点都是对等的，但它自己就构成一个分布式系统。</p>
<p>也就是说，分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群，是指同一种组件的多个实例，形成的逻辑上的整体。</p>
<p>可以看出这两个概念并不完全冲突，分布式系统也可以是一个集群，例子就是前面说的zookeeper等，它的特征是服务之间会互相通信协作。是分布式系统不是集群的情况，就是多个不同组件构成的系统；是集群不是分布式系统的情况，比如多个经过负载均衡的HTTP服务器，它们之间不会互相通信，如果不带上负载均衡的部分的话，一般不叫做分布式系统。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10安装PyGraphviz]]></title>
        <id>https://sheldie.github.io/post/Win10安装PyGraphviz/</id>
        <link href="https://sheldie.github.io/post/Win10安装PyGraphviz/">
        </link>
        <updated>2020-04-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="正确安装方法">正确安装方法</h4>
<p>提前安装好graphviz并配置环境变量<br>
然后在：https://github.com/CristiFati/Prebuilt-Binaries<br>
下载对应py版本和系统的版本<br>
到目录中执行<code>pip install pygraphviz-1.5-cp37-cp37m-win_amd64.whl</code></p>
<h4 id="以下为个人经历">以下为个人经历</h4>
<p>anaconda的环境为python3.7，<br>
由于需要安装Causalnex的关系，<br>
需要使用到pygraphviz，然而安装的时候发现与各种库的版本有冲突。。</p>
<p>于是新建项目和虚拟环境<br>
重新尝试<code>pip install graphviz</code><br>
报错：Microsoft Visual C++ 14.0 is required.<br>
（新电脑没安装Visual Studio)</p>
<p>安装重启过后，<br>
报错fatal error C1083: 无法打开包括文件: “graphviz/cgraph.h”</p>
<p>在网上寻找解决方案，<br>
尝试直接下载whl文件并安装：https://www.lfd.uci.edu/~gohlke/pythonlibs/#pygraphviz<br>
但是发现没有对应版本，只有python3.4的版本。<br>
强行下载尝试，报错：not a supported wheel</p>
<p>尝试使用conda新建一个python3.4的虚拟环境<br>
倒腾半天，发现pycharm已不支持python3.4<br>
于是删除</p>
<p>然后尝试直接下载源代码并安装：https://github.com/pygraphviz/pygraphviz<br>
果然还是报错fatal error C1083: 无法打开包括文件: “graphviz/cgraph.h”</p>
<p>最后在网上找到了该库的编译版本...</p>
<p>吐了。</p>
<p>现正学习并尝试使用Casualnex...</p>
<h5 id="2020-04-04-更新">2020-04-04 更新：</h5>
<p>尝试使用CausalNex过后，发现这个库应该是还在开发中。。<br>
使用起来挺不稳定的，近一个月还更改过集成的库<br>
本来用的是networkx，后来换成pygraphviz的</p>
<p>安装的时候就出现了版本不兼容的问题<br>
运行示例代码就出现了很多问题，报错也极其诡异<br>
粗略判断还是版本问题</p>
<p>本人水平有限，最近精力也有限...<br>
机器学习这方面基本是零基础<br>
最近也是在网上找些样例在学习<br>
主要还是把重点放在比较基础的操作上吧<br>
有时间和条件多了解一些相关原理</p>
<p>因为了解不够也没法很好地提出问题<br>
所以这个库还是暂时弃用吧<br>
会继续关注 希望能逐步完善好~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[配置GiTalk]]></title>
        <id>https://sheldie.github.io/post/配置GiTalk/</id>
        <link href="https://sheldie.github.io/post/配置GiTalk/">
        </link>
        <updated>2020-01-01T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>😃 给博客开放一下评论功能~</p>
]]></summary>
        <content type="html"><![CDATA[<p>😃 给博客开放一下评论功能~</p>
<!-- more -->
<ol>
<li>
<p>首先在Github中进行以下设置：</p>
<ul>
<li>
<p>打开<code>Github - Settings - Developer Settings - OAuth Apps - New OAuth App</code></p>
</li>
<li>
<p>填写必要信息：<br>
<code>Application name</code>填 Gitalk<br>
<code>Homepage URL</code> 和 <code>Authorization callback URL</code> 填自己 Github Pages 的博客域名<br>
（如：https://sheldie.github.io/）</p>
</li>
<li>
<p>点击Register Application</p>
</li>
<li>
<p>打开后能看到<code>Client ID</code>和<code>Client Secret</code></p>
</li>
</ul>
</li>
<li>
<p>在Github新建一个 public 仓库，仓库名自取</p>
</li>
<li>
<p>在<code>Gridea - 远程 - 评论配置</code>中选择 GiTalk + 显示评论<br>
填入<code>Client ID</code>和<code>Client Secret</code><br>
填入刚才创建的仓库名称<br>
Owner填写自己Github的用户名</p>
</li>
</ol>
<p>详细内容可以打开GiTalk Document查看<br>
在Gridea中保存设置并同步后<br>
打开任意文章页 - 使用Github登录后便可以进行评论<br>
内容会出现在仓库的Issues中，可以进行修改和删除</p>
<p>到这里就配置完成了😀</p>
<hr>
<p>2020-04-13:</p>
<p>总结两个问题：</p>
<ol>
<li>
<blockquote>
<p>未找到相关的 <a href="https://github.com/Sheldie/sheldie.GiTalk/issues">Issues</a> 进行评论<br>
请联系 @Sheldie 初始化创建</p>
</blockquote>
<p>发布文章后，打开对应文章页登录Github账号，会自动创建Issue<br>
否则无法进行评论</p>
</li>
<li>
<p>部分文章出现 Error: Validation Failed.</p>
<p>原因是某些文章标题较长，自动创建Issue时，超出了50字符限制</p>
<p>解决方法：打开所用主题的源代码，找到相关部分</p>
<pre><code>  var gitalk = new Gitalk({
    clientID: '&lt;%= commentSetting.gitalkSetting.clientId %&gt;',
    clientSecret: '&lt;%= commentSetting.gitalkSetting.clientSecret %&gt;',
    repo: '&lt;%= commentSetting.gitalkSetting.repository %&gt;',
    owner: '&lt;%= commentSetting.gitalkSetting.owner %&gt;',
    admin: ['&lt;%= commentSetting.gitalkSetting.owner %&gt;'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
</code></pre>
<p>可以看到pure主题也有提示<br>
id 需要保证长度和唯一性<br>
将<code>id: location.pathname</code><br>
改为<code>id: decodeURI(location.pathname)</code><br>
解码后长度会变短</p>
<p>同样也可以转成 md5<br>
相关问题可参考：https://github.com/gitalk/gitalk/issues/102</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://sheldie.github.io/post/hello-gridea/</id>
        <link href="https://sheldie.github.io/post/hello-gridea/">
        </link>
        <updated>2019-12-31T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>