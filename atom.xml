<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sheldie.github.io</id>
    <title>Shezzer&apos;s Blog</title>
    <updated>2020-09-04T07:26:01.059Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sheldie.github.io"/>
    <link rel="self" href="https://sheldie.github.io/atom.xml"/>
    <subtitle>Shezzer的技术博客</subtitle>
    <logo>https://sheldie.github.io/images/avatar.png</logo>
    <icon>https://sheldie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shezzer&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[课程资源整理]]></title>
        <id>https://sheldie.github.io/post/课程资源整理/</id>
        <link href="https://sheldie.github.io/post/课程资源整理/">
        </link>
        <updated>2020-09-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="机器学习-吴恩达">机器学习 - 吴恩达</h4>
<p>Coursera课程地址：https://www.coursera.org/learn/machine-learning<br>
含英文字幕，可学习相关英文词汇。</p>
<p>中英字幕视频：https://www.bilibili.com/video/BV164411b7dx</p>
<p>中文笔记：https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes</p>
<h4 id="深度学习-吴恩达">深度学习 - 吴恩达</h4>
<p>视频： https://www.bilibili.com/video/BV1gb411j7Bs<br>
https://www.bilibili.com/video/BV164411m79z</p>
<p>中文笔记：https://github.com/fengdu78/deeplearning_ai_books</p>
<p>在线笔记：http://www.ai-start.com/dl2017/</p>
<h4 id="cs231n-convolutional-neural-networks-for-visual-recognition">CS231n: Convolutional Neural Networks for Visual Recognition</h4>
<h5 id="面向视觉识别的卷积神经网络">面向视觉识别的卷积神经网络</h5>
<p>课程官网：http://vision.stanford.edu/teaching/cs231n/index.html</p>
<p>笔记总集：https://zhuanlan.zhihu.com/p/21930884</p>
<h4 id="其他课程">其他课程</h4>
<p>cs229，cs224n，cs294，cs246<br>
mit：6004，6828，线代，boyd优化</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask简单入门]]></title>
        <id>https://sheldie.github.io/post/Flask简单入门/</id>
        <link href="https://sheldie.github.io/post/Flask简单入门/">
        </link>
        <updated>2020-05-27T03:30:20.000Z</updated>
        <summary type="html"><![CDATA[<p>使用python的Web框架实现简单网页</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用python的Web框架实现简单网页</p>
<!-- more -->
<p>最近需要用到Python的Web框架做个简单的网页，在Django和Flask间选择了比较轻量的Flask。</p>
<blockquote>
<p>Flask是一个使用 Python 编写的轻量级 Web 应用框架。<br>
其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。Flask使用 BSD 授权。</p>
<p>WSGI：Web Server Gateway Interface（Web服务器网关接口，WSGI）已被用作Python Web应用程序开发的标准。 WSGI是Web服务器和Web应用程序之间通用接口的规范。</p>
<p>Werkzeug：它是一个WSGI工具包，它实现了请求，响应对象和实用函数。 这使得能够在其上构建web框架。 Flask框架使用Werkzeug作为其基础之一。</p>
<p>jinja2：jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。</p>
<p>Flask通常被称为微框架。 它旨在保持应用程序的核心简单且可扩展。Flask没有用于数据库处理的内置抽象层，也没有形成验证支持。相反，Flask支持扩展以向应用程序添加此类功能。一些受欢迎的Flask扩展将在本教程后续章节进行讨论。</p>
</blockquote>
<p>需求：能展示简单的网页。</p>
<p>之前好像安装过：</p>
<pre><code>pip install Flask
</code></pre>
<p>首先在根目录新建<code>manage.py</code>。<br>
尝试最简单的应用：Hello world!</p>
<pre><code>from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

if __name__ == '__main__':
    app.run()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://sheldie.github.io/post-images/1590550389268.png" alt="" loading="lazy"></figure>
<p>打开：http://127.0.0.1:5000/ 就能看到Hello World了。</p>
<p>但是这样是不够的，我们需要直接编辑html文件来修改前端页面。<br>
于是在根目录下新建文件夹<code>app</code>，在<code>app</code>文件夹下再新建<code>__init__.py</code>和<code>routes.py</code>。</p>
<p><code>__init__.py</code>：</p>
<pre><code>from flask import Flask

app = Flask(__name__)

from app import routes
</code></pre>
<p><code>routes.py</code>：</p>
<pre><code>from flask import render_template
from app import app

@app.route('/')
@app.route('/home')
def home():
    return render_template(&quot;home.html&quot;)
</code></pre>
<p>将<code>manage.py</code>修改如下：</p>
<pre><code>from app import app

if __name__ == '__main__':
    app.debug = True
    app.run()
</code></pre>
<p>然后在<code>app</code>文件夹下新建两个文件夹：<code>static</code>, <code>templates</code><br>
<code>static</code>中放置静态文件如css，js和图片等。<br>
<code>templates</code>中放置html文件（如home.html等）</p>
<p>如果从服务端访问页面，则只读取<code>templates</code>中的html文件，不能读取其中的图片。<br>
静态图片只能放在<strong>static</strong>文件夹下，路径为：</p>
<pre><code>&lt;img src=&quot;static/xxx.png&quot;&gt;
</code></pre>
<p>完成以上步骤后再次运行<code>manage.py</code>，就能看到自己的html网页了。</p>
<p>如需添加其他页面，将html文件放置在<code>templates</code>文件夹下，在<code>routes.py</code>下配置相关路由。<br>
另外可以传递数据，目前没大量使用到，因此参考了其他博客。<br>
<code>routes.py</code>：</p>
<pre><code>from flask import render_template
from app import app

@app.route('/')
@app.route('/index')
def index():
    user = {'username':'用户'}
    posts = [
        {
            'author':{'username':'用户1'},
            'body':'这是模板模块中的循环例子～1'

        },
        {
            'author': {'username': '用户2'},
            'body': '这是模板模块中的循环例子～2'
        }
    ]
    return render_template('index.html',title='标题',user=user,posts=posts)
</code></pre>
<p><code>app/templates/index.html</code> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
     {% if title %}
        &lt;title&gt;{{ title }} - 博客&lt;/title&gt;
        {% else %}
        &lt;title&gt;欢迎来到博客!&lt;/title&gt;
        {% endif %}
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;你好, {{ user.username }} !&lt;/h1&gt;
        {% for post in posts %}
            &lt;div&gt;&lt;p&gt;{{ post.author.username }} 说:&lt;b&gt;{{ post.body }}&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;
        {% endfor %}

    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>目前以上使用基本能满足需求，之后有需要会再深入学习。<br>
其他可以做到的有：连接数据库、蓝图、创建基类模板等。</p>
<p>比较完整的项目框架结构有：</p>
<pre><code>| - projectName
	| - app  //程序包
		| - templates //jinjia2模板
		|- static //css,js 图片等静态文件
		| - main  //py程序包 ，可以有多个这种包，每个对应不同的功能
			| - __init__.py
			|- errors.py
			|- forms.py
			|- views.py
		|- __init__.py
		|- email.py //邮件处理程序
		|- models.py //数据库模型
	|- migrations //数据迁移文件夹
	| - tests  //单元测试
		|- __init__.py
		|- test*.py //单元测试程序，可以包含多个对应不同的功能点测试
	|- venv  //虚拟环境
	|- requirements.txt //列出了所有依赖包以及版本号，方便在其他位置生成相同的虚拟环境以及依赖
	|- config.py //全局配置文件，配置全局变量
	|- manage.py //启动程序
</code></pre>
<pre><code>project/
    app/                    # 整个程序的包目录
        static/                 # 静态资源文件
            js/                     # JS脚本
            css/                    # 样式表
            img/                    # 图片
            favicon.ico              # 网站图标
        templates/              # 模板文件
            common/                 # 通用模板
            errors/                 # 错误页面
            user/                   # 用户模板
            posts/                  # 帖子模板
            email/                  # 邮件发送
        views/                  # 视图文件
        models/                 # 数据模型
        forms/                  # 表单文件
        config.py               # 配置文件
        email.py                # 邮件发送
        extensions.py           # 各种扩展
    migrations/             # 数据库迁移目录
    tests/                  # 测试单元
    venv/                   # 虚拟环境
    requirements.txt        # 依赖包的列表
    manage.py               # 项目启动控制文件
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://sheldie.github.io/post-images/1590550411169.png" alt="" loading="lazy"></figure>
<hr>
<p>部分转载自：</p>
<ol>
<li>https://blog.csdn.net/u014793102/article/details/80372815</li>
<li>https://zhuanlan.zhihu.com/p/65205656</li>
<li>https://blog.csdn.net/pzl_pzl/article/details/80861329</li>
<li>https://blog.csdn.net/xingyunLOST/article/details/77155584</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL相关知识点]]></title>
        <id>https://sheldie.github.io/post/MySQL相关知识点/</id>
        <link href="https://sheldie.github.io/post/MySQL相关知识点/">
        </link>
        <updated>2020-04-30T05:00:19.000Z</updated>
        <summary type="html"><![CDATA[<p>数据库相关知识点，持续更新。</p>
]]></summary>
        <content type="html"><![CDATA[<p>数据库相关知识点，持续更新。</p>
<!-- more -->
<h3 id="数据库字段设计">数据库字段设计</h3>
<h4 id="为什么要一定要设置主键">为什么要一定要设置主键?</h4>
<p>其实这个不是一定的，有些场景下，小系统或者没什么用的表，不设置主键也没关系，mysql最好是用自增主键，主要是以下两个原因：如果定义了主键，那么InnoDB<strong>会选择主键作为聚集索引</strong>、如果没有显式定义主键，则innodb 会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则innodb 会选择内置6字节长的ROWID作为隐含的聚集索引。所以，反正都要生成一个主键，那你还不如自己指定一个主键，提高查询效率！</p>
<h4 id="主键是用自增还是uuid">主键是用自增还是UUID?</h4>
<p>最好是用自增主键，主要是以下两个原因：</p>
<ol>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会<strong>自动开辟一个新的页</strong>。</li>
<li>如果使用非自增主键（如uuid），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到索引页的随机某个位置，此时MySQL为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多<strong>开销</strong>，同时频繁的移动、分页操作造成索引碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li>
</ol>
<p>不过，也不是所有的场景下都得使用自增主键，可能场景下，主键必须自己生成，不在乎那些性能的开销。那也没有问题。</p>
<h4 id="自增主键用完了怎么办">自增主键用完了怎么办?</h4>
<p>在mysql中，Int整型的范围（-2147483648~2147483648），约20亿！因此不用考虑自增ID达到最大值这个问题。而且数据达到千万级的时候就应该考虑分库分表了。</p>
<h4 id="主键为什么不推荐有业务含义">主键为什么不推荐有业务含义?</h4>
<p>最好是主键是无意义的自增ID，然后另外创建一个业务主键ID，因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发<strong>页分裂</strong>，产生空间碎片。</p>
<p>还有就是，带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</p>
<h4 id="货币字段用什么类型">货币字段用什么类型?</h4>
<p>货币字段一般都用Decimal类型，<br>
float和double是以二进制存储的，数据大的时候，可能存在误差。</p>
<h4 id="时间字段用什么类型">时间字段用什么类型?</h4>
<p>这个看具体情况和实际场景，timestamp ，datatime ，bigint 都行！</p>
<p>timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。<br>
但是它有一个优势，<strong>timestamp类型是带有时区信息的</strong>。一旦你系统中的时区发生改变，例如你修改了时区，该字段的值会自动变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！</p>
<p>datetime，占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，它存储的是时间绝对值，<strong>不带有时区信息</strong>。如果你改变数据库的时区，该项的值不会自己发生变更！</p>
<p>bigint，也是8个字节，自己维护一个时间戳，查询效率高，不过数据写入，显示都需要做<strong>转换</strong>。这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是<strong>数据的可读性太差</strong>了，你无法直观的看到具体时间。</p>
<h4 id="为什么不直接存储图片-音频-视频等大容量内容">为什么不直接存储图片、音频、视频等大容量内容?</h4>
<p>我们在实际应用中，都是文件形式存储的。mysql中，只存文件的存放路径。虽然mysql中blob类型可以用来存放大容量文件，但是，我们在生产中，基本不用！</p>
<p>主要有如下几个原因：</p>
<ul>
<li>Mysql<strong>内存临时表</strong>不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，查询效率会非常慢。</li>
<li>数据库特别大，内存占用高，维护也比较麻烦。</li>
<li>binlog太大，如果是主从同步的架构，会导致主从同步效率问题！</li>
</ul>
<p>因此，不推荐使用blob等类型！</p>
<h4 id="表中有大字段x例如text类型且字段x不会经常更新以读为主那么是拆成子表好还是放一起好">表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，那么是拆成子表好？还是放一起好？</h4>
<p>其实各有利弊，拆开带来的问题：连接消耗；不拆可能带来的问题：查询性能，所以要看你的实际情况，如果表数据量比较大，最好还是拆开为好。这样查询速度更快。</p>
<h4 id="字段为什么要定义为not-null">字段为什么要定义为NOT NULL?</h4>
<p>一般情况，都会设置一个默认值，不会出现字段里面有null，又有空的情况。主要有以下几个原因：</p>
<ol>
<li>
<p>索引性能不好，Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。</p>
</li>
<li>
<p>如果某列存在null的情况，可能导致count() 等函数执行不对的情况。</p>
</li>
<li>
<p>sql 语句写着也麻烦，既要判断是否为空，又要判断是否为null等。</p>
</li>
</ol>
<h3 id="数据库查询优化">数据库查询优化</h3>
<h4 id="where执行顺序是怎样的">where执行顺序是怎样的？</h4>
<p>where 条件从左往右执行的，在数据量小的时候不用考虑，但数据量多的时候要考虑条件的先后顺序，此时应遵守一个原则：排除越多的条件放在第一个。</p>
<h4 id="应该在这些列上创建索引">应该在这些列上创建索引</h4>
<p>在<strong>经常需要搜索</strong>的列上，可以加快搜索的速度；在作为<strong>主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在<strong>连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据<strong>范围</strong>进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要<strong>排序</strong>的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在<strong>WHERE子句</strong>中的列上面创建索引，加快条件的判断速度。</p>
<h4 id="mysql联合索引">mysql联合索引</h4>
<p>联合索引是两个或更多个列上的索引。对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是<strong>最左侧部分</strong>。例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。<br>
利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</p>
<h4 id="什么是最左前缀原则">什么是最左前缀原则？</h4>
<p>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。</p>
<pre><code class="language-sql">select * from user where name=xx and city=xx ; ／／可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引
</code></pre>
<p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会<strong>自动优化</strong>为匹配联合索引的顺序，这样是能够命中索引的。</p>
<p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。</p>
<h4 id="什么情况下应不建或少建索引">什么情况下应不建或少建索引</h4>
<p>表记录太少<br>
经常插入、删除、修改的表<br>
<strong>数据重复且分布平均</strong>的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。<br>
经常和主字段一块查询但主字段索引值比较多的表字段</p>
<h4 id="mysql数据库cpu飙升到100的话怎么处理">MySQL数据库cpu飙升到100%的话怎么处理？</h4>
<ol>
<li>列出所有进程 show process list 观察所有进程 多秒没有状态变化的(干掉)</li>
<li>查看<strong>慢查询</strong>，找出执行时间长的sql；explain分析sql是否走<strong>索引</strong>，<strong>sql优化</strong>；</li>
<li>检查其他子系统是否正常，是否<strong>缓存失效</strong>引起，需要查看buffer命中率；</li>
</ol>
<h4 id="mysql中表锁和行锁的区别">mysql中表锁和行锁的区别</h4>
<p>Mysql有很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁；这些锁统称为悲观锁(Pessimistic Lock)</p>
<p><strong>行锁</strong><br>
特点：锁的粒度小，发生锁冲突的概率低、处理并发的能力强；开销大、加锁慢、会出现死锁<br>
加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加<strong>排他锁</strong>；对于普通SELECT语句，InnoDB不会加任何锁。</p>
<p><strong>表锁</strong><br>
特点：开销小、加锁快、无死锁；锁粒度大，发生锁冲突的概率高，高并发下性能低<br>
加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加<strong>读锁</strong>，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加<strong>写锁</strong>。</p>
<h4 id="mysql主键索引和普通索引之间的区别是什么">mysql主键索引和普通索引之间的区别是什么</h4>
<p><strong>普通索引</strong><br>
普通索引是最基本的索引类型，而且它没有唯一性之类的限制。普通索引可以通过以下几种方式创建：</p>
<pre><code>创建索引，例如
CREATE INDEX &lt;索引的名字&gt; ON tablename (列的列表);
修改表，例如
ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表);
创建表的时候指定索引，例如
CREATE TABLE tablename ( [...],INDEX[索引的名字] (列的列表) );
</code></pre>
<p><strong>主键索引</strong><br>
主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”。<br>
主键一般在创建表的时候指定，例如</p>
<pre><code>CREATE TABLE tablename ( [...],PRIMARY KEY(列的列表) );
</code></pre>
<p>但是，我们也可以通过修改表的方式加入主键，例如“ALTER TABLE tablename ADD PRIMARY KEY (列的列表); ”。每个表只能有一个主键。</p>
<p><strong>区别</strong><br>
普通索引是最基本的索引类型，没有任何限制，值可以为空，仅<strong>加速查询</strong>。普通索引是可以重复的，一个表中可以有多个普通索引。<br>
主键索引是一种特殊的<strong>唯一索引</strong>，一个表只能有一个主键，<strong>不允许有空值</strong>；索引列的所有值都只能出现一次，即必须唯一。简单来说：主键索引是加速查询 + 列值唯一（不可以有null）+ 表中只有一个。</p>
<h4 id="sql-join-中-on-与-where-的区别">SQL JOIN 中 on 与 where 的区别</h4>
<ul>
<li><strong>left join</strong> : 左连接，返回左表中所有的记录以及右表中连接字段相等的记录。</li>
<li><strong>right join</strong> : 右连接，返回右表中所有的记录以及左表中连接字段相等的记录。</li>
<li><strong>inner join</strong> : 内连接，又叫等值连接，只返回两个表中连接字段相等的行。</li>
<li><strong>full join</strong> : 外连接，返回两个表中的行：left join + right join。</li>
<li><strong>cross join</strong> : 结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。</li>
</ul>
<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的<strong>临时表</strong>，然后再将这张临时表返回给用户。<br>
在使用 <strong>left join</strong> 时，<strong>on</strong> 和 <strong>where</strong> 条件的区别如下：</p>
<ol>
<li>
<p><strong>on</strong> 条件是在生成临时表时使用的条件，它不管 <strong>on</strong> 中的条件是否为真，都会返回左边表中的记录。</p>
</li>
<li>
<p><strong>where</strong> 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 <strong>left join</strong> 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p>
</li>
</ol>
<h4 id="优化-mysql-数据库的方法">优化 MYSQL 数据库的方法</h4>
<ul>
<li>
<p>选取最适用的字段属性，尽可能减少定义字段长度，尽量把字段设置 NOT NULL, 例如’省份，性别’, 最好设置为 ENUM</p>
</li>
<li>
<p>使用连接（JOIN）来代替子查询:</p>
</li>
<li>
<p>使用联合 (UNION) 来代替手动创建的临时表</p>
</li>
<li>
<p>事务处理</p>
</li>
<li>
<p>锁定表，优化事务处理</p>
</li>
<li>
<p>使用外键，优化锁定表</p>
</li>
<li>
<p>建立索引</p>
</li>
<li>
<p>优化 sql 语句</p>
</li>
</ul>
<h4 id="一个汉字占多少长度">一个汉字占多少长度</h4>
<p>与编码有关<br>
UTF-8： 一个汉字=3个字节<br>
GBK：一个汉字=2个字节</p>
<h4 id="什么时候适合创建索引">什么时候适合创建索引</h4>
<p>适合创建索引条件：</p>
<ul>
<li>主键自动建立唯一索引</li>
<li><strong>频繁作为查询条件</strong>的字段应该建立索引</li>
<li>查询中与其他表关联的字段，<strong>外键关系</strong>建立索引</li>
<li>单键/组合索引的选择问题，组合索引性价比更高</li>
<li>查询中排序的字段，<strong>排序字段</strong>若通过索引去访问将大大提高排序效率</li>
<li>查询中统计或者<strong>分组字段</strong></li>
</ul>
<p>不适合创建索引条件：</p>
<ul>
<li>表<strong>记录少</strong>的</li>
<li><strong>经常增删改</strong>的表或者字段</li>
<li>where条件里用不到的字段不创建索引</li>
<li><strong>过滤性不好</strong>的不适合建索引</li>
</ul>
<h4 id="常见的sql语句">常见的sql语句</h4>
<ul>
<li>表名order中有 1 2 3 4 1<br>
去掉重复值 sql : select distinct from order<br>
结果为company 1 2 3 4</li>
<li>asc 是升序 是从小到大 desc 是大到小 group 是分组</li>
<li>IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。</li>
<li>查找学生<br>
查询姓“赵”的用户 select * from table where name like '赵%'<br>
查询姓名中最后一个字段带赵字 select * from table where name like '%赵'<br>
查询姓名中带有赵的字段 select * from table where name like '%赵%'</li>
<li>汇总分析<br>
查询一个学生总分 select sum(*) from table where 课程号='0002'<br>
查询选课程的学生人数 select count(distinct 学号) as 学生人数 from table</li>
<li>分组<br>
查询各科成绩最高和最低的分<br>
select 课程号 max（成绩）as 最高分，min（成绩）as 最低分 from table group by 课程号<br>
查询每门课程被选修的学生数<br>
select 课程号，count(学号) from score group by 课程号<br>
查询男生和女生人数<br>
select 性别，count(*) from tabel group by 性别</li>
<li>分组结果的条件<br>
查询平均成绩大于60分的学号和平均成绩<br>
select 学号，avg(成绩)from group by 学号 having avg(成绩) &gt; 60<br>
查询至少选修俩门课程的学生学号<br>
select 学号,count(课程号)as 选修课程数目 from table group by 学号 having count(课程号)&gt;=2;<br>
查询同名同性学生名单并统计人数<br>
select 姓名，count() as 人数 from table group by 姓名 having count(*)&gt;=2;<br>
查询不及格的课程并按课程号从大到小排序<br>
select 课程号 from table where 成绩&lt;60 order by 课程号 desc;</li>
</ul>
<h3 id="数据库事务">数据库事务</h3>
<h4 id="事务">事务</h4>
<h4 id="事务的特性">事务的特性</h4>
<ol>
<li>
<p>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>
</li>
<li>
<p>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>
</li>
<li>
<p>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
</li>
<li>
<p>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
</li>
</ol>
<h4 id="事务隔离级别">事务隔离级别</h4>
<hr>
<p>部分转载自：</p>
<ol>
<li>https://zhuanlan.zhihu.com/p/116866170</li>
<li>https://www.cnblogs.com/wyaokai/p/10921323.html</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KNN算法]]></title>
        <id>https://sheldie.github.io/post/KNN算法/</id>
        <link href="https://sheldie.github.io/post/KNN算法/">
        </link>
        <updated>2020-04-22T05:17:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="算法概述">算法概述</h3>
<p>KNN可以说是最简单的分类算法之一，同时，它也是最常用的分类算法之一，注意KNN算法是有监督学习中的分类算法，它看起来和另一个机器学习算法Kmeans有点像（Kmeans是无监督学习算法），但却是有本质区别的。其指导思想是”近朱者赤，近墨者黑“，即由你的邻居来推断出你的类别。</p>
<p>最简单最初级的分类器是将全部的训练数据所对应的类别都记录下来，当测试对象的属性和某个训练对象的属性完全匹配时，便可以对其进行分类。但是怎么可能所有测试对象都会找到与之完全匹配的训练对象呢，其次就是存在一个测试对象同时与多个训练对象匹配，导致一个训练对象被分到了多个类的问题，基于这些问题呢，就产生了KNN。</p>
<p>KNN是通过测量不同特征值之间的距离进行分类。它的思路是：如果一个样本在特征空间中的k个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别，其中K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。</p>
<p>如下图所示，如何判断绿色圆应该属于哪一类，是属于红色三角形还是属于蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被判定为属于红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆将被判定为属于蓝色四方形类。<br>
<img src="https://sheldie.github.io/post-images/1587532688031.png" alt="" loading="lazy"><br>
由于KNN最邻近分类算法在分类决策时只依据最邻近的一个或者几个样本的类别来决定待分类样本所属的类别，而不是靠判别类域的方法来确定所属类别的，因此对于<strong>类域的交叉或重叠较多的待分样本集</strong>来说，KNN方法较其他方法更为适合。</p>
<h3 id="算法介绍">算法介绍</h3>
<p>KNN算法的结果很大程度取决于K值的选择。</p>
<p>在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离：<br>
<img src="https://sheldie.github.io/post-images/1587532744965.jpg" alt="" loading="lazy"><br>
对KNN算法的思想进行总结：就是在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为：</p>
<ol>
<li>计算测试数据与各个训练数据之间的距离；</li>
<li>按照距离的递增关系进行排序；</li>
<li>选取距离最小的K个点；</li>
<li>确定前K个点所在类别的出现频率；</li>
<li>返回前K个点中出现频率最高的类别作为测试数据的预测分类。</li>
</ol>
<p>KNN算法的关键：</p>
<blockquote>
<ol>
<li>样本的所有特征都要做可比较的量化<br>
若是样本特征中存在非数值的类型，必须采取手段将其量化为数值。例如样本特征中包含颜色，可通过将颜色转换为灰度值来实现距离计算。</li>
<li>样本特征要做归一化处理<br>
样本有多个参数，每一个参数都有自己的定义域和取值范围，他们对距离计算的影响不一样，如取值较大的影响力会盖过取值较小的参数。所以样本参数必须做一些 scale 处理，最简单的方式就是所有特征的数值都采取归一化处置。</li>
<li>需要一个距离函数以计算两个样本之间的距离<br>
通常使用的距离函数有：欧氏距离、余弦距离、汉明距离、曼哈顿距离等，一般选欧氏距离作为距离度量，但是这是只适用于连续变量。在文本分类这种非连续变量情况下，汉明距离可以用来作为度量。通常情况下，如果运用一些特殊的算法来计算度量的话，K近邻分类精度可显著提高，如运用大边缘最近邻法或者近邻成分分析法。</li>
</ol>
</blockquote>
<p>K值选的太大易引起欠拟合，太小容易过拟合，需交叉验证确定K值（将样本数据按照一定比例，拆分出训练用的数据和验证用的数据，比如6：4拆分出部分训练数据和验证数据），从选取一个较小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K值。<br>
<img src="https://sheldie.github.io/post-images/1587532734421.png" alt="" loading="lazy"><br>
这个图其实很好理解，当增大k的时候，一般错误率会先降低，因为有周围更多的样本可以借鉴了，分类效果会变好。但注意，和K-means不一样，当K值更大的时候，错误率会更高。这也很好理解，比如说你一共就35个样本，当你K增大到30的时候，KNN基本上就没意义了。</p>
<p>所以选择K点的时候可以选择一个较大的临界K点，当它继续增大或减小的时候，错误率都会上升，比如图中的K=10。</p>
<h3 id="算法特点">算法特点</h3>
<p>KNN是一种<strong>非参的</strong>，<strong>惰性</strong>的算法模型。</p>
<p><strong>非参</strong>的意思并不是说这个算法不需要参数，而是意味着这个模型不会对数据做出任何的假设，与之相对的是线性回归（我们总会假设线性回归是一条直线）。也就是说KNN建立的模型结构是根据数据来决定的，这也比较符合现实的情况，毕竟在现实中的情况往往与理论上的假设是不相符的。</p>
<p><strong>惰性</strong>又是什么意思呢？想想看，同样是分类算法，逻辑回归需要先对数据进行大量训练（tranning），最后才会得到一个算法模型。而KNN算法却不需要，它没有明确的训练数据的过程，或者说这个过程很快。</p>
<p>算法优点：</p>
<ol>
<li>简单，易于理解，易于实现，无需估计参数，模型训练时间快</li>
<li>适合对稀有事件进行分类，对异常值不敏感</li>
<li>特别适合于多分类问题(multi-modal,对象具有多个类别标签)， KNN比SVM的表现要好。</li>
</ol>
<p>算法缺点：</p>
<ol>
<li>对内存要求较高，因为该算法存储了所有训练数据</li>
<li>预测阶段可能很慢</li>
<li>对不相关的功能和数据规模敏感（当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。可以采用权值的方法来改进。）</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://sheldie.github.io/post-images/1587532766265.png" alt="" loading="lazy"></figure>
<hr>
<p>转载自：</p>
<ol>
<li>https://www.cnblogs.com/ybjourney/p/4702562.html</li>
<li>https://www.cnblogs.com/listenfwind/p/10311496.html</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统知识点汇总]]></title>
        <id>https://sheldie.github.io/post/操作系统知识点汇总/</id>
        <link href="https://sheldie.github.io/post/操作系统知识点汇总/">
        </link>
        <updated>2020-04-17T02:00:30.000Z</updated>
        <summary type="html"><![CDATA[<p>总结一些操作系统的基本概念，持续整理更新。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总结一些操作系统的基本概念，持续整理更新。</p>
<!-- more -->
<p>最近需要复习整理一下基础知识<br>
以下内容为转载整理，主要为个人学习使用。</p>
<h3 id="基本概念">基本概念</h3>
<h4 id="操作系统">操作系统</h4>
<h5 id="操作系统的定义">操作系统的定义</h5>
<p>操作系统是<strong>管理计算机硬件与软件资源的计算机程序</strong>。它加在裸机上的第一层软件，是整个计<br>
算机系统的核心，是系统应用程序和用户程序与硬件之间的接口。</p>
<h5 id="操作系统的功能">操作系统的功能</h5>
<ul>
<li><strong>处理器管理</strong>：处理器管理最基本的功能是<strong>处理中断</strong>事件，配置操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是<strong>处理器调度</strong>，针对不同情况采取不同的调度策略。</li>
<li><strong>存储器管理</strong>：存储器管理主要是指针对内存储器的管理。主要任务是<strong>分配内存空间</strong>，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中<strong>不互相干扰</strong>。</li>
<li><strong>设备管理</strong>：设备管理是指负责管理各类外围设备，包括分配、启动和故障处理等。主要任务是当用户使用外部设备时，必须提出要求，待操作系统进行统一分配后方可使用，使得多个用户能够<strong>共享设备</strong>。</li>
<li><strong>文件管理</strong>：文件管理是指操作系统对信息资源的管理。在操作系统中，将负责存取的管理信息的部分称为文件系统。文件管理支持文件的<strong>存储</strong>、<strong>检索</strong>和<strong>修改</strong>等操作以及文件的<strong>保护</strong>功能。</li>
<li><strong>作业管理</strong>：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制，这是根据用户的需要来控制作业运行的。</li>
<li><strong>用户接口</strong>：对用户与操作系统之间实际通讯的各种方式进行管理，为用户提供一个使用系统的良好环境。</li>
</ul>
<h5 id="操作系统的基本特征">操作系统的基本特征</h5>
<ul>
<li>并发性：concurrency</li>
<li>共享性：sharing</li>
<li>虚拟技术：virtual technology（时分复用 / 空分复用）</li>
<li>异步性：asynchronism</li>
</ul>
<h5 id="多道程序设计">多道程序设计</h5>
<ul>
<li>多道程序设计（multiprogramming）是指让多个程序同时进入计算机的主存储器进行计算。一般来说，单个程序并不能让 CPU 和 I/O 设备始终忙碌。单个用户通常具有多个运行程序。多道程序设计通过安排作业（编码与数据）使得 CPU 总有一个执行作业，从而提高 CPU 利用率。</li>
<li>特点：
<ul>
<li>多道、宏观上并行、微观上串行</li>
<li>CPU与外部设备充分并行</li>
<li>外部设备之间充分并行</li>
<li>发挥CPU的使用效率</li>
<li>提高单位时间的算题量</li>
</ul>
</li>
<li>不足：系统管理复杂化</li>
</ul>
<p>时间片</p>
<h4 id="操作系统的类型">操作系统的类型</h4>
<p>批处理操作系统、分时系统、实时系统、分布式操作系统、网络操作系统</p>
<h5 id="批处理操作系统">批处理操作系统</h5>
<h5 id="分时系统">分时系统</h5>
<ul>
<li>
<p>特点：共享性、并行性、<strong>交互性</strong>、独占性</p>
</li>
<li>
<p>分时系统要求计算机系统是<strong>可交互的</strong>（interactive），以便用户与系统直接通信。用户通过输入设备，如键盘、鼠标、触摸板、触摸屏等向操作系统或程序发出指令，并等待输出设备的即时结果。相应地，响应时间（response time）应当较短，通常小于 1 秒。</p>
</li>
<li>
<p>分时操作系统允许<strong>许多用户同时共享一台计算机</strong>。由于分时系统的每个动作或命令往往较短，因而每个用户只需少量 CPU 时间。随着系统从一个用户快速切换到另一个用户，每个用户都会感到整个系统只为自己所用，尽管它事实上为许多用户所共享。</p>
</li>
<li>
<p>分时操作系统采用 <strong>CPU 调度</strong>和<strong>多道程序设计</strong>，为每个用户提供一小部分的分时计算机资源。每个用户至少有一个程序在内存中。加载到内存并执行的程序，通常称为进程（process）。当进程执行时，它通常在执行较短的一段时间后，要么完成，要么需要进行 I/O 操作。</p>
</li>
<li>
<p>I/O 可以是交互的，即输出是到用户显示器，输入来自用户键盘、鼠标或其他设备。由于交互 I/O 通常按人类速度（people speed）来进行，因此可能需要很长时间完成。例如，输入通常受限于用户打字速度，每秒 7 个字符对人类来说可能很快，但是对计算机来说太慢了。在用户进行交互输入时，操作系统为了不让 CPU 空闲，会将 CPU 切换到其他用户程序。</p>
</li>
<li>
<p>分时系统和多道程序需要<strong>在内存中同时保存多个作业</strong>。如果有多个作业可以加载到内 存，同时内存太小而不能容纳所有这些作业，那么系统就应做出选择（这个决定涉及<strong>作业调度</strong>（job scheduling））。操作系统从作业池中选中一个作业，并将它调入内存以便执行。内存同时保存多个程序，这需要一定形式的内存管理。</p>
</li>
<li>
<p>另外，如果有多个任务同时等待执行，那么系统应当做出选择。做出这样的决策称为 <strong>CPU 调度</strong>（CPU scheduling）。最后，在多个作业并发执行时，操作系统的各个阶段，如进程调度、磁盘和内存管理，应能限制作业之间的互相影响。</p>
</li>
<li>
<p>对于分时系统，操作系统必须确保合理的响应时间。这有时可以通过交换（swapping）来得到，交换可将进程从磁盘调入内存，也可将进程从内存调到磁盘。不过，<strong>虚拟内存</strong>（virtual memory）是实现合理响应时间的更为常用的一种方法，虚拟内存允许一个执行作业不必完全在内存中。</p>
</li>
<li>
<p>虚拟内存的主要优点是，用户可执行比物理内存（physical memory）大的程序。再者，它将内存抽象成一个庞大的、统一的存储数组，将用户理解的逻辑内存（logical memory）与真正的物理内存区分幵来。这种安排使得程序员不受内存空间的限制。</p>
</li>
<li>
<p>分时系统也应提供文件系统。文件系统驻留在一组磁盘上，因此 也应提供磁盘管理。另外，分时系统需要提供机制，以便保护资源并防止不当使用。为了确保有序执行，系统必须提供机制，以便实现作业的同步和通信；它也可确保作业不会进入死锁，进而永远互相等待。</p>
</li>
<li>
<p><strong>分时系统和批处理系统的区别</strong>：目标不同、 适应作业的性质不同、资源使用率不同、作业控制方式不同</p>
</li>
</ul>
<hr>
<h3 id="进程">进程</h3>
<h4 id="程序执行">程序执行</h4>
<h5 id="程序的顺序执行">程序的顺序执行</h5>
<ul>
<li>指的是在有多个程序需要执行的情况下，处理器严格按照某一顺序按序执行，每次只执行一个程序。这个程序独占系统中所有资源，其执行不受外界影响，一道程序执行完后另一道才能开始。其实质是单道程序系统。</li>
<li>特点
<ul>
<li>顺序性：一个程序开始执行必须要等到前一个程序已执行完成</li>
<li>封闭性：程序一旦开始执行，其计算结果不受外界因素影响</li>
<li>可再现性：程序的结果与它的执行速度无关（即与时间无关），只要给定相同的输入，一定会得到相同的结果。</li>
</ul>
</li>
<li>不足：效率低下</li>
</ul>
<h4 id="并行与并发">并行与并发</h4>
<h5 id="并行与并发的概念">并行与并发的概念</h5>
<ul>
<li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</li>
<li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br>
<img src="https://sheldie.github.io/post-images/1587295176243.jpg" alt="并发与并行" loading="lazy"></li>
</ul>
<h5 id="程序并发执行的特点">程序并发执行的特点</h5>
<ul>
<li>
<p>资源共享性（失去封闭性）</p>
</li>
<li>
<p>独立性和制约性</p>
</li>
<li>
<p>程序执行的间断性</p>
</li>
<li>
<p>结果不可再现</p>
</li>
</ul>
<h4 id="进程和线程">进程和线程</h4>
<h5 id="进程和线程的概念">进程和线程的概念</h5>
<ul>
<li>进程：
<ul>
<li>是资源分配的最小单位。</li>
<li>一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>一个程序与其数据一道通过处理机的执行所发生的活动。</li>
</ul>
</li>
<li>线程：是进程的一个执行单元，是进程内的调度实体，是CPU调度的最小单位。</li>
</ul>
<h5 id="进程的特征">进程的特征</h5>
<ul>
<li>动态性：进程是程序的执行</li>
<li>并发性：多个进程可同存于内存中，能在一段时间内同时运行</li>
<li>独立性：独立运行的基本单位，独立获得资源和调度的基本单位</li>
<li>异步性：各进程按各自独立的不可预知的速度向前推进</li>
<li>结构特征：由用户程序 、用户数据、系统栈和进程控制块四部分组成</li>
</ul>
<h5 id="进程的类型">进程的类型</h5>
<ul>
<li>按其任务性质分：系统进程、用户进程</li>
<li>按其活动特点分：科学计算（受CPU时间限制）、商业联机事务处理（受I/O限制）</li>
</ul>
<h5 id="为什么需要进程">为什么需要进程？</h5>
<h5 id="为什么需要线程">为什么需要线程？</h5>
<p>每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。</p>
<ul>
<li>线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。</li>
<li>进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。</li>
</ul>
<h5 id="进程与程序的区别">进程与程序的区别</h5>
<ul>
<li>行为的一个规则叫做程序，程序在处理机上执行时所发生的活动称为进程</li>
<li><strong>程序是指令的有序集合</strong>，其本身没有任何运行的含义，是一个<strong>静态</strong>的概念。而进程是程序在处理机上的一次执行过程，它是一个<strong>动态</strong>的概念。</li>
<li>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<strong>程序是永久的，进程是暂时的。</strong></li>
<li>进程更能真实地描述并发，而程序不能</li>
<li>进程是由程序和数据两部分组成的</li>
<li>进程具有创建其他进程的功能，而程序没有</li>
<li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。</li>
</ul>
<h5 id="进程与线程的区别">进程与线程的区别</h5>
<ul>
<li><strong>根本区别</strong>：<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></li>
<li><strong>地址空间</strong>：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>
<li><strong>资源分配</strong>：进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
<ul>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</li>
</ul>
</li>
<li><strong>执行环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</li>
<li><strong>执行过程</strong>：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li><strong>切换开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li>
<li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
<li><strong>优缺点</strong>：<br>
线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。<br>
进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。</li>
<li><strong>使用场景</strong>：<br>
对资源的管理和保护要求高，不限制开销和效率时，使用多进程。<br>
要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</li>
</ul>
<blockquote>
<p>做个简单的比喻：进程=火车，线程=车厢</p>
<ul>
<li>线程在进程下行进（单纯的车厢无法运行）</li>
<li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li>
<li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li>
<li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li>
<li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li>
<li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－&quot;互斥锁&quot;</li>
<li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li>
</ul>
</blockquote>
<h4 id="进程的状态及转换">进程的状态及转换</h4>
<h5 id="进程的三种基本状态">进程的三种基本状态</h5>
<ul>
<li><strong>就绪状态（Ready）</strong>：存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行。这些进程所处的状态为就绪状态。</li>
<li><strong>运行状态（Running）</strong>：正在运行的进程所处的状态为运行状态。拥有CPU。</li>
<li><strong>等待状态（Wait / Blocked）</strong>：若一进程正在等待某一事件发生（如等待输入输出工作完成），这时，即使给它CPU，它也无法运行，称该进程处于等待状态、阻塞、 睡眠、封锁状态。</li>
</ul>
<blockquote>
<p>进程状态模型<br>
<img src="https://sheldie.github.io/post-images/1587295018931.png" alt="进程状态模型" loading="lazy"><br>
运行：进程当前处于运行状态。<br>
就绪；进程已准备好运行。<br>
阻塞；进程等待某些事件发生（如I/O操作）后才能运行。<br>
创建：进程刚产生，但还未被操作系统提交到可运行进程池中。<br>
消失（撤销）：进程被操作系统从可运行进程池中释放。</p>
</blockquote>
<h5 id="进程挂起">进程挂起</h5>
<p>处于非运行状态的进程：内存 → 外存</p>
<p>由于I/O操作比CPU计算慢得多，故常会出现内存中所有进程都等待I/O的现象。即使运行多个程序，处理器在大多数时间仍处于空闲状态。为此可采用交换方法，将内存中的一部分进程转移到磁盘中。在进程行为模式中需增加一个新的挂起状态，当内存所有进程阻塞时，操作系统可将一进程置为挂起状态并交换到磁盘，再调入另一进程执行。</p>
<p>挂起状态与原有的阻塞和就绪状态结合为<strong>阻塞挂起</strong>状态和<strong>就绪挂起</strong>状态。</p>
<blockquote>
<p>带有一个挂起状态<br>
<img src="https://sheldie.github.io/post-images/1587295052118.png" alt="带有一个挂起状态" loading="lazy"><br>
带有两个挂起状态<br>
<img src="https://sheldie.github.io/post-images/1587295122555.png" alt="带有两个挂起状态" loading="lazy"></p>
</blockquote>
<h4 id="进程控制块">进程控制块</h4>
<h5 id="进程控制块的概念">进程控制块的概念</h5>
<ul>
<li>为了描述一个进程和其它进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个<strong>与进程相联系的数据块</strong>，称为进程控制块（PCB）。</li>
<li>系统利用PCB来控制和管理进程，所以PCB是系统<strong>感知进程存在的唯一标志</strong></li>
<li>进程与PCB是一一对应的</li>
</ul>
<h5 id="进程控制块的内容">进程控制块的内容</h5>
<ul>
<li>进程标识
<ul>
<li>本进程的标识符(process ID)，唯一，通常是一个整数</li>
<li>创建本进程的进程（父进程）的标识符</li>
<li>用户标识符(user ID)；进程组关系</li>
</ul>
</li>
<li>处理器状态信息
<ul>
<li>通用寄存器</li>
<li>指令计数器</li>
<li>程序状态字PSW（状态码、状态信息）</li>
<li>用户栈指针</li>
</ul>
</li>
<li>进程调度信息
<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>调度所需其他信息：等待时间/执行时间等与调度算法有关</li>
<li>等待的事件</li>
</ul>
</li>
<li>进程控制信息
<ul>
<li>程序和数据地址</li>
<li>进程同步和通信机制：信号量、消息队列指针</li>
<li>资源清单</li>
<li>链接指针：下一个PCB的首址</li>
</ul>
</li>
</ul>
<hr>
<h3 id="死锁">死锁</h3>
<h4 id="死锁的定义">死锁的定义</h4>
<h5 id="死锁的概念">死锁的概念</h5>
<p>并发执行带来了新的问题：死锁。<br>
死锁是指<strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong>（互相等待），若无外力作用，它们都将无法再向前推进。</p>
<h5 id="死锁的实例">死锁的实例</h5>
<p>生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（同时拥有2只筷子才能吃）。某一个时候，一个拿了左筷子，一人拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭。<br>
在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p>
<h4 id="死锁产生的原因">死锁产生的原因</h4>
<ul>
<li>
<p>竞争资源</p>
<ul>
<li>
<p>系统中的<strong>资源可以分为两类</strong></p>
<ol>
<li><strong>可剥夺资源</strong>，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li><strong>不可剥夺资源</strong>，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ol>
</li>
<li>
<p>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
</li>
<li>
<p>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
</li>
</ul>
</li>
<li>
<p>进程间推进顺序非法</p>
<ul>
<li>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁</li>
<li>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</li>
</ul>
</li>
</ul>
<h4 id="死锁产生的必要条件">死锁产生的必要条件</h4>
<ul>
<li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程--资源的环形链。</li>
</ul>
<h4 id="解决死锁的方法">解决死锁的方法</h4>
<p>预防死锁、避免死锁、检查死锁、解除死锁</p>
<h5 id="预防死锁">预防死锁</h5>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
<ul>
<li>以确定的顺序获得锁：比如说进程P1：使用资源的顺序是R1、R2，进程P2：使用资源的顺序是R2、R1，如果采取动态分配的方式，就很有可能造成死锁。我们对设备进行分类编号，那么P1、P2只能以R1、R2的顺序来申请资源。就可以打破环形回路，避免死锁。</li>
<li>超时放弃：按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。</li>
</ul>
</li>
</ul>
<h5 id="避免死锁">避免死锁</h5>
<p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前<strong>预先计算资源分配的安全性</strong>。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法，它是DIJKstra E.W于1968年提出来的。</p>
<p>为什么叫做银行家算法呢，是因为这有点像银行的“借贷”服务，假如银行只有有限多的资金供给客户进行贷款服务，那么为了保证银行能有足够的资金运转，它在借钱之前要审核客户是否有能够在指定时间内偿还贷款的能力。<br>
在研究我们的操作系统的资源分配策略时，也会出现类似的问题，我们系统中的有限资源要分配给各种进程，那么就要事先考察此进程是否有在指定期限内归还资源的能力。必须要保证它能在有限的时间内进行归还，拱其他进程使用。</p>
<p>大致实现方法：</p>
<ol>
<li>当一个进程对资源的<strong>最大需求量不超过系统中的资源数时可以接纳该进程</strong>。</li>
<li>进程<strong>可以分期请求资源</strong>，当请求的总数不能超过最大需求量。</li>
<li>当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以<strong>推迟分配</strong>，但总能使进程在有限的时间里得到资源。</li>
<li>当系统现有的资源能满足进程尚需资源数时，必须测试<strong>系统现存的资源能否满足该进程尚需的最大资源数</strong>，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li>
</ol>
<p>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
<h5 id="检测死锁">检测死锁</h5>
<ul>
<li>首先为每个进程和每个资源指定一个唯一的号码</li>
<li>然后建立资源分配表和进程等待表</li>
</ul>
<h5 id="解除死锁">解除死锁</h5>
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<ul>
<li><strong>剥夺资源</strong>：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</li>
<li><strong>撤消进程</strong>：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</li>
</ul>
<hr>
<p>部分转载自：</p>
<ol>
<li>https://blog.csdn.net/hd12370/article/details/82814348</li>
<li>https://blog.csdn.net/ls5718/article/details/51896159?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1</li>
<li>https://www.zhihu.com/question/25532384/answer/411179772</li>
<li>https://www.cnblogs.com/zhuzhu2016/p/5804875.html</li>
<li>http://c.biancheng.net/view/1175.html</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划]]></title>
        <id>https://sheldie.github.io/post/动态规划/</id>
        <link href="https://sheldie.github.io/post/动态规划/">
        </link>
        <updated>2020-04-16T07:30:30.000Z</updated>
        <summary type="html"><![CDATA[<p>总结动态规划问题的基本思路（待更新）</p>
]]></summary>
        <content type="html"><![CDATA[<p>总结动态规划问题的基本思路（待更新）</p>
<!-- more -->
<h3 id="基本思路">基本思路</h3>
<p>图片转载自<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">leetcode</a></p>
<figure data-type="image" tabindex="1"><img src="https://sheldie.github.io/post-images/1587022409662.png" alt="动态规划问题的基本思路" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python词频统计]]></title>
        <id>https://sheldie.github.io/post/python词频统计/</id>
        <link href="https://sheldie.github.io/post/python词频统计/">
        </link>
        <updated>2020-04-14T14:23:47.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 Python 对 txt 文件做简单的词频统计</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 Python 对 txt 文件做简单的词频统计</p>
<!-- more -->
<p>今天由于某些原因，实现了个简单的文本词频统计。</p>
<h3 id="背景">背景</h3>
<p>Python方面仍然还是入门水准，使用起来并不是很顺手。<br>
正则表达式也不是很熟，学习了一些最基本的用法，后续会进行整理。</p>
<h3 id="需求">需求</h3>
<ol>
<li>读入文件</li>
<li>实现对文本中单词的词频统计</li>
<li>将单词的出现位置输出到文件中</li>
<li>根据单词词性，将 名词单复数 及 动词各种形式 看作同一个单词<code>（难）</code></li>
</ol>
<h3 id="思路">思路</h3>
<p>首先读入文件。</p>
<p>然后按行来读取文件，每行按正则表达式读取单词。<br>
这里我用的是：<code>[a-zA-Z\']+</code><br>
有些单词内可能有 ‘，所以把这个也写入正则表达式了。</p>
<p>新建一个<strong>列表</strong>和一个<strong>字典</strong><br>
直接将读取到的单词存入列表<br>
把该单词的位置 以<strong>元组</strong>的形式 存入字典，字典值的数据类型为列表<br>
元组格式为：<code>（行号，单词序数）</code>，如第1行第3个单词为 (0, 2)</p>
<p>整个文本都读取完之后<br>
利用Counter直接对列表中的单词词频进行统计<br>
将字典中存储的位置输出到一个新的txt文件中</p>
<h3 id="代码">代码</h3>
<pre><code>def wordcount(filename):
    fi = open(filename, &quot;r&quot;, encoding=&quot;utf-8-sig&quot;)
    words_box = []
    words_idx = {}

    row = 0
    for line in fi.readlines():
        line = line.rstrip('\n').strip().lower()
        ls = re.findall('[a-zA-Z\']+', line)

        idx = 0
        for word in ls:
            if word not in words_idx:
                words_idx[word] = []
            words_idx[word].append((row, idx))
            idx += 1

        row += 1

    counter = Counter(words_box)
    for i in counter:
        print('%s: %d' % (i, counter.get(i)))

    fo = open(&quot;result.txt&quot;, 'w+', encoding=&quot;utf-8&quot;)
    for word in sorted(words_idx):
        op = word + ' ' + str(words_idx.get(word)) + '\n'
        print(op, end=&quot;&quot;)
        fo.write(op)
</code></pre>
<p>有个细节：打开文件后读取第一行时，最前面出现了<code>\ufeff</code>（字节顺序标记）</p>
<p>找到的资料如下：<br>
UTF-8以字节为编码单元，它的字节顺序在所有系统中都是一样的，没有字节序的问题，也因此它实际上并不需要BOM(“ByteOrder Mark”)。但是UTF-8 with BOM即utf-8-sig需要提供BOM。</p>
<p>因此将编码格式改为<code>utf-8-sig</code>即可。</p>
<hr>
<p>目前来说除了第四条需求都已基本完成。</p>
<p>关于词性判断，也就是第四条需求，感觉难度过大。<br>
初步判断需要借助库，涉及NLP，有点超出我目前的学习范围，暂时弃坑。<br>
网上搜索资料后，找到<strong>NLTK</strong>库。<br>
观察了运行结果，应该是比较符合需求的。</p>
<p>思路是：判断出单词词性后，对后缀进行调整或者删除，再进行统计或者匹配。<br>
找了一篇相关的经验贴：<a href="https://www.jianshu.com/p/418cbdbf5e20">Python nltk 英文词性分析</a><br>
例如：判断出该单词为NNS（名词复数），可以考虑删除 s 和 es 等后缀。<br>
理论上来说是有可操作性的，以后若使用到NLTK会进行尝试。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式与集群]]></title>
        <id>https://sheldie.github.io/post/分布式与集群/</id>
        <link href="https://sheldie.github.io/post/分布式与集群/">
        </link>
        <updated>2020-04-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="单机结构"><strong>单机结构</strong></h3>
<p>我想大家最最最熟悉的就是单机结构，一个系统业务量很小的时候所有的代码都放在一个项目中就好了，然后这个项目部署在一台服务器上就好了。整个项目所有的服务都由这台服务器提供。这就是单机结构。</p>
<p>那么，单机结构有啥缺点呢？我想缺点是显而易见的，单机的处理能力毕竟是有限的，当你的业务增长到一定程度的时候，单机的硬件资源将无法满足你的业务需求。此时便出现了集群模式，往下接着看。</p>
<h3 id="集群结构"><strong>集群结构</strong></h3>
<p>单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。</p>
<p>但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。</p>
<p>集群结构的好处就是系统扩展非常容易。如果随着你们系统业务的发展，当前的系统又支撑不住了，那么给这个集群再增加节点就行了。但是，当你的业务发展到一定程度的时候，你会发现一个问题——无论怎么增加节点，貌似整个集群性能的提升效果并不明显了。这时候，你就需要使用微服务结构了。</p>
<h3 id="分布式结构"><strong>分布式结构</strong></h3>
<p>先来对前面的知识点做个总结。</p>
<p>从单机结构到集群结构，你的代码基本无需要作任何修改，你要做的仅仅是多部署几台服务器，每台服务器上运行相同的代码就行了。但是，当你要从集群结构演进到微服务结构的时候，之前的那套代码就需要发生较大的改动了。所以对于新系统我们建议，系统设计之初就采用微服务架构，这样后期运维的成本更低。但如果一套老系统需要升级成微服务结构的话，那就得对代码大动干戈了。所以，对于老系统而言，究竟是继续保持集群模式，还是升级成微服务架构，这需要你们的架构师深思熟虑、权衡投入产出比。</p>
<p>OK，下面开始介绍所谓的分布式结构。</p>
<p>分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。</p>
<p>举个例子，假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。</p>
<p>这样的好处有很多：</p>
<ol>
<li>系统之间的耦合度大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。</li>
<li>系统之间的耦合度降低，从而系统更易于扩展。我们可以针对性地扩展某些服务。假设这个商城要搞一次大促，下单量可能会大大提升，因此我们可以针对性地提升订单系统、产品系统的节点数量，而对于后台管理系统、数据分析系统而言，节点数量维持原有水平即可。</li>
<li>服务的复用性更高。比如，当我们将用户系统作为单独的服务后，该公司所有的产品都可以使用该系统作为用户系统，无需重复开发。</li>
</ol>
<h3 id="补充">补充</h3>
<p>其实分布式不一定就是不同的组件，同一个组件也可以，关键在于是否通过交换信息的方式进行协作。比如说Zookeeper的节点都是对等的，但它自己就构成一个分布式系统。</p>
<p>也就是说，分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群，是指同一种组件的多个实例，形成的逻辑上的整体。</p>
<p>可以看出这两个概念并不完全冲突，分布式系统也可以是一个集群，例子就是前面说的zookeeper等，它的特征是服务之间会互相通信协作。是分布式系统不是集群的情况，就是多个不同组件构成的系统；是集群不是分布式系统的情况，比如多个经过负载均衡的HTTP服务器，它们之间不会互相通信，如果不带上负载均衡的部分的话，一般不叫做分布式系统。</p>
<hr>
<p>转载自：</p>
<ol>
<li>
<p>分布式与集群的区别是什么？ - 大闲人柴毛毛的回答 - 知乎<br>
https://www.zhihu.com/question/20004877/answer/282033178</p>
</li>
<li>
<p>分布式与集群的区别是什么？ - 灵剑的回答 - 知乎<br>
https://www.zhihu.com/question/20004877/answer/568581790</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10安装PyGraphviz]]></title>
        <id>https://sheldie.github.io/post/Win10安装PyGraphviz/</id>
        <link href="https://sheldie.github.io/post/Win10安装PyGraphviz/">
        </link>
        <updated>2020-04-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="正确安装方法">正确安装方法</h4>
<p>提前安装好graphviz并配置环境变量<br>
然后在：https://github.com/CristiFati/Prebuilt-Binaries<br>
下载对应py版本和系统的版本<br>
到目录中执行<code>pip install pygraphviz-1.5-cp37-cp37m-win_amd64.whl</code></p>
<h4 id="以下为个人经历">以下为个人经历</h4>
<p>anaconda的环境为python3.7，<br>
由于需要安装Causalnex的关系，<br>
需要使用到pygraphviz，然而安装的时候发现与各种库的版本有冲突。。</p>
<p>于是新建项目和虚拟环境<br>
重新尝试<code>pip install graphviz</code><br>
报错：Microsoft Visual C++ 14.0 is required.<br>
（新电脑没安装Visual Studio)</p>
<p>安装重启过后，<br>
报错fatal error C1083: 无法打开包括文件: “graphviz/cgraph.h”</p>
<p>在网上寻找解决方案，<br>
尝试直接下载whl文件并安装：https://www.lfd.uci.edu/~gohlke/pythonlibs/#pygraphviz<br>
但是发现没有对应版本，只有python3.4的版本。<br>
强行下载尝试，报错：not a supported wheel</p>
<p>尝试使用conda新建一个python3.4的虚拟环境<br>
倒腾半天，发现pycharm已不支持python3.4<br>
于是删除</p>
<p>然后尝试直接下载源代码并安装：https://github.com/pygraphviz/pygraphviz<br>
果然还是报错fatal error C1083: 无法打开包括文件: “graphviz/cgraph.h”</p>
<p>最后在网上找到了该库的编译版本...</p>
<p>吐了。</p>
<p>现正学习并尝试使用Casualnex...</p>
<h5 id="2020-04-04-更新">2020-04-04 更新：</h5>
<p>尝试使用CausalNex过后，发现这个库应该是还在开发中。。<br>
使用起来挺不稳定的，近一个月还更改过集成的库<br>
本来用的是networkx，后来换成pygraphviz的</p>
<p>安装的时候就出现了版本不兼容的问题<br>
运行示例代码就出现了很多问题，报错也极其诡异<br>
粗略判断还是版本问题</p>
<p>本人水平有限，最近精力也有限...<br>
机器学习这方面基本是零基础<br>
最近也是在网上找些样例在学习<br>
主要还是把重点放在比较基础的操作上吧<br>
有时间和条件多了解一些相关原理</p>
<p>因为了解不够也没法很好地提出问题<br>
所以这个库还是暂时弃用吧<br>
会继续关注 希望能逐步完善好~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客说明]]></title>
        <id>https://sheldie.github.io/post/博客说明/</id>
        <link href="https://sheldie.github.io/post/博客说明/">
        </link>
        <updated>2020-01-03T13:56:49.000Z</updated>
        <summary type="html"><![CDATA[<p>本博客新建于2020年4月 ✌️<br>
主要用于个人学习 🚀<br>
以前的内容就不搬过来了<br>
之后会陆续更新的~</p>
]]></summary>
        <content type="html"><![CDATA[<p>本博客新建于2020年4月 ✌️<br>
主要用于个人学习 🚀<br>
以前的内容就不搬过来了<br>
之后会陆续更新的~</p>
<!-- more -->
]]></content>
    </entry>
</feed>